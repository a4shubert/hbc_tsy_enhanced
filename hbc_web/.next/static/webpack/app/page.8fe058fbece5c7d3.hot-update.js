"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/hbc/HbcAgTable.tsx":
/*!***************************************!*\
  !*** ./components/hbc/HbcAgTable.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HbcAgTable: function() { return /* binding */ HbcAgTable; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var ag_grid_community_styles_ag_grid_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ag-grid-community/styles/ag-grid.css */ \"(app-pages-browser)/./node_modules/ag-grid-community/styles/ag-grid.css\");\n/* harmony import */ var ag_grid_community_styles_ag_theme_quartz_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ag-grid-community/styles/ag-theme-quartz.css */ \"(app-pages-browser)/./node_modules/ag-grid-community/styles/ag-theme-quartz.css\");\n/* harmony import */ var ag_grid_community__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ag-grid-community */ \"(app-pages-browser)/./node_modules/ag-grid-community/dist/package/main.esm.mjs\");\n/* harmony import */ var ag_grid_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ag-grid-react */ \"(app-pages-browser)/./node_modules/ag-grid-react/dist/package/index.esm.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n// HbcAgTable.tsx\n/* __next_internal_client_entry_do_not_use__ HbcAgTable auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\nlet agGridRegistered = false;\nif (!agGridRegistered) {\n    ag_grid_community__WEBPACK_IMPORTED_MODULE_5__.ModuleRegistry.registerModules([\n        ag_grid_community__WEBPACK_IMPORTED_MODULE_5__.AllCommunityModule\n    ]);\n    agGridRegistered = true;\n}\nfunction HbcAgTable(param) {\n    let { rowData, columnDefs, className, height = \"100%\", loading, error, gridOptions, rowIdField, onGridReady, onFilterChanged, onSortChanged, onSelectionChanged, onCellClicked, onCellDoubleClicked, onCellKeyDown, onFilterPaste } = param;\n    _s();\n    const gridApiRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null);\n    const columnFilterTypeByColId = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>{\n        const map = new Map();\n        for (const def of columnDefs !== null && columnDefs !== void 0 ? columnDefs : []){\n            var _def_colId;\n            const colId = (_def_colId = def.colId) !== null && _def_colId !== void 0 ? _def_colId : def.field;\n            if (!colId) continue;\n            map.set(colId, def.filter);\n        }\n        return map;\n    }, [\n        columnDefs\n    ]);\n    async function copyText(text) {\n        try {\n            var _navigator_clipboard, _navigator;\n            if ((_navigator = navigator) === null || _navigator === void 0 ? void 0 : (_navigator_clipboard = _navigator.clipboard) === null || _navigator_clipboard === void 0 ? void 0 : _navigator_clipboard.writeText) {\n                await navigator.clipboard.writeText(text);\n                return;\n            }\n        } catch (e) {\n        // ignore and fall back\n        }\n        const el = document.createElement(\"textarea\");\n        el.value = text;\n        el.setAttribute(\"readonly\", \"true\");\n        el.style.position = \"fixed\";\n        el.style.top = \"-9999px\";\n        document.body.appendChild(el);\n        el.select();\n        document.execCommand(\"copy\");\n        document.body.removeChild(el);\n    }\n    function handleCellKeyDown(e) {\n        var _ev_key;\n        onCellKeyDown === null || onCellKeyDown === void 0 ? void 0 : onCellKeyDown(e);\n        const ev = e.event;\n        if (!ev) return;\n        const key = (_ev_key = ev.key) === null || _ev_key === void 0 ? void 0 : _ev_key.toLowerCase();\n        const isCopy = (ev.metaKey || ev.ctrlKey) && key === \"c\" && !ev.shiftKey && !ev.altKey;\n        if (!isCopy) return;\n        const value = e.value;\n        if (value === null || value === undefined) return;\n        const text = typeof value === \"string\" ? value : String(value);\n        ev.preventDefault();\n        void copyText(text);\n    }\n    function findFloatingFilterColumnId(target) {\n        var _target_closest;\n        if (!target || !(target instanceof HTMLElement)) return null;\n        const direct = (_target_closest = target.closest(\"[col-id]\")) === null || _target_closest === void 0 ? void 0 : _target_closest.getAttribute(\"col-id\");\n        if (direct && direct.length) return direct;\n        const floating = target.closest(\".ag-floating-filter\");\n        if (!floating) return null;\n        const headerCell = target.closest(\".ag-header-cell\");\n        const colId = headerCell === null || headerCell === void 0 ? void 0 : headerCell.getAttribute(\"col-id\");\n        return colId && colId.length ? colId : null;\n    }\n    function setEqualsForTextFilter(colId, filterText) {\n        var _api_onFilterChanged;\n        const api = gridApiRef.current;\n        if (!api) return;\n        var _api_getFilterModel;\n        const model = (_api_getFilterModel = api.getFilterModel()) !== null && _api_getFilterModel !== void 0 ? _api_getFilterModel : {};\n        const existing = model[colId];\n        const nextText = typeof filterText === \"string\" ? filterText : existing === null || existing === void 0 ? void 0 : existing.filter;\n        if (typeof nextText !== \"string\") return;\n        const trimmed = nextText.trim();\n        if (!trimmed) return;\n        const existingType = (existing === null || existing === void 0 ? void 0 : existing.type) ? String(existing.type).toLowerCase() : \"\";\n        const existingValue = typeof (existing === null || existing === void 0 ? void 0 : existing.filter) === \"string\" ? existing.filter.trim() : \"\";\n        if (existingType === \"equals\" && existingValue === trimmed) return;\n        var _existing_filterType;\n        api.setFilterModel({\n            ...model,\n            [colId]: {\n                ...existing !== null && existing !== void 0 ? existing : {},\n                filterType: (_existing_filterType = existing === null || existing === void 0 ? void 0 : existing.filterType) !== null && _existing_filterType !== void 0 ? _existing_filterType : \"text\",\n                type: \"equals\",\n                filter: trimmed\n            }\n        });\n        (_api_onFilterChanged = api.onFilterChanged) === null || _api_onFilterChanged === void 0 ? void 0 : _api_onFilterChanged.call(api);\n    }\n    function parseDateFromText(input) {\n        const text = input.trim();\n        if (!text) return null;\n        const isoMatch = /^(\\d{4}-\\d{2}-\\d{2})/.exec(text);\n        if (isoMatch) return isoMatch[1];\n        const ms = Date.parse(text);\n        if (!Number.isFinite(ms)) return null;\n        const d = new Date(ms);\n        const yyyy = String(d.getFullYear()).padStart(4, \"0\");\n        const mm = String(d.getMonth() + 1).padStart(2, \"0\");\n        const dd = String(d.getDate()).padStart(2, \"0\");\n        return \"\".concat(yyyy, \"-\").concat(mm, \"-\").concat(dd);\n    }\n    function setEqualsForDateFilter(colId, filterText) {\n        var _api_onFilterChanged;\n        const api = gridApiRef.current;\n        if (!api) return;\n        var _api_getFilterModel;\n        const model = (_api_getFilterModel = api.getFilterModel()) !== null && _api_getFilterModel !== void 0 ? _api_getFilterModel : {};\n        const existing = model[colId];\n        const nextText = typeof filterText === \"string\" ? filterText : existing === null || existing === void 0 ? void 0 : existing.dateFrom;\n        if (typeof nextText !== \"string\") return;\n        const dateFrom = parseDateFromText(nextText);\n        if (!dateFrom) return;\n        const existingType = (existing === null || existing === void 0 ? void 0 : existing.type) ? String(existing.type).toLowerCase() : \"\";\n        const existingDateFrom = typeof (existing === null || existing === void 0 ? void 0 : existing.dateFrom) === \"string\" ? existing.dateFrom.trim() : \"\";\n        if (existingType === \"equals\" && existingDateFrom === dateFrom) return;\n        api.setFilterModel({\n            ...model,\n            [colId]: {\n                ...existing !== null && existing !== void 0 ? existing : {},\n                filterType: \"date\",\n                type: \"equals\",\n                dateFrom\n            }\n        });\n        (_api_onFilterChanged = api.onFilterChanged) === null || _api_onFilterChanged === void 0 ? void 0 : _api_onFilterChanged.call(api);\n    }\n    function getPreferredFilterType(colId) {\n        const api = gridApiRef.current;\n        var _api_getFilterModel;\n        const model = (_api_getFilterModel = api === null || api === void 0 ? void 0 : api.getFilterModel()) !== null && _api_getFilterModel !== void 0 ? _api_getFilterModel : {};\n        const existing = model[colId];\n        const existingFilterType = typeof (existing === null || existing === void 0 ? void 0 : existing.filterType) === \"string\" ? existing.filterType : undefined;\n        if (existingFilterType) return existingFilterType;\n        const colFilter = columnFilterTypeByColId.get(colId);\n        if (colFilter === \"agDateColumnFilter\") return \"date\";\n        if (colFilter === \"agNumberColumnFilter\") return \"number\";\n        return \"text\";\n    }\n    function handleKeyDownCapture(ev) {\n        var _ev_key;\n        const key = (_ev_key = ev.key) === null || _ev_key === void 0 ? void 0 : _ev_key.toLowerCase();\n        const isCopy = (ev.metaKey || ev.ctrlKey) && key === \"c\" && !ev.shiftKey && !ev.altKey;\n        const isPaste = (ev.metaKey || ev.ctrlKey) && key === \"v\" && !ev.shiftKey && !ev.altKey;\n        if (!isCopy && !isPaste) return;\n        const colId = findFloatingFilterColumnId(ev.target);\n        if (!colId) {\n            if (isCopy) {\n                const text = getFocusedCellText();\n                if (!text) return;\n                ev.preventDefault();\n                void copyText(text);\n            }\n            return;\n        }\n        if (isPaste) {\n            onFilterPaste === null || onFilterPaste === void 0 ? void 0 : onFilterPaste(colId);\n            window.setTimeout(()=>{\n                const el = ev.target;\n                const value = el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement ? el.value : undefined;\n                const filterType = getPreferredFilterType(colId);\n                if (filterType === \"date\") {\n                    setEqualsForDateFilter(colId, value);\n                    return;\n                }\n                setEqualsForTextFilter(colId, value);\n            }, 40);\n            return;\n        }\n        if (isCopy) {\n            const text = getFocusedCellText();\n            if (!text) return;\n            ev.preventDefault();\n            void copyText(text);\n        }\n    }\n    function handlePasteCapture(ev) {\n        const colId = findFloatingFilterColumnId(ev.target);\n        if (!colId) return;\n        onFilterPaste === null || onFilterPaste === void 0 ? void 0 : onFilterPaste(colId);\n        window.setTimeout(()=>{\n            const el = ev.target;\n            const value = el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement ? el.value : undefined;\n            const filterType = getPreferredFilterType(colId);\n            if (filterType === \"date\") {\n                setEqualsForDateFilter(colId, value);\n                return;\n            }\n            setEqualsForTextFilter(colId, value);\n        }, 40);\n    }\n    function getFocusedCellText() {\n        var _api_getFocusedCell, _api_getDisplayedRowAtIndex, _focused_column_getColId, _focused_column, _rowNode_data;\n        const api = gridApiRef.current;\n        if (!api) return null;\n        const focused = (_api_getFocusedCell = api.getFocusedCell) === null || _api_getFocusedCell === void 0 ? void 0 : _api_getFocusedCell.call(api);\n        if (!focused) return null;\n        const rowNode = (_api_getDisplayedRowAtIndex = api.getDisplayedRowAtIndex) === null || _api_getDisplayedRowAtIndex === void 0 ? void 0 : _api_getDisplayedRowAtIndex.call(api, focused.rowIndex);\n        const colId = (_focused_column = focused.column) === null || _focused_column === void 0 ? void 0 : (_focused_column_getColId = _focused_column.getColId) === null || _focused_column_getColId === void 0 ? void 0 : _focused_column_getColId.call(_focused_column);\n        if (!rowNode || !colId) return null;\n        const value = (_rowNode_data = rowNode.data) === null || _rowNode_data === void 0 ? void 0 : _rowNode_data[colId];\n        if (value === null || value === undefined) return null;\n        return typeof value === \"string\" ? value : String(value);\n    }\n    const autoColumnDefs = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>{\n        if (columnDefs && columnDefs.length) return columnDefs;\n        var _rowData_;\n        const keys = Object.keys((_rowData_ = rowData === null || rowData === void 0 ? void 0 : rowData[0]) !== null && _rowData_ !== void 0 ? _rowData_ : {});\n        return keys.map((field)=>({\n                field\n            }));\n    }, [\n        columnDefs,\n        rowData\n    ]);\n    const defaultColDef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>({\n            resizable: true,\n            sortable: true,\n            unSortIcon: true,\n            filter: true,\n            floatingFilter: true,\n            minWidth: 140\n        }), []);\n    const mergedGridOptions = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>({\n            theme: \"legacy\",\n            animateRows: true,\n            rowSelection: \"single\",\n            suppressCellFocus: false,\n            pagination: false,\n            alwaysShowHorizontalScroll: true,\n            suppressHorizontalScroll: false,\n            suppressRowClickSelection: true,\n            enableCellTextSelection: true,\n            ensureDomOrder: true,\n            ...gridOptions !== null && gridOptions !== void 0 ? gridOptions : {}\n        }), [\n        gridOptions\n    ]);\n    const finalClassName = [\n        \"hbc-ag-grid ag-theme-quartz-dark w-full rounded-lg border border-[color:var(--color-border)] bg-[color:var(--color-card)]\",\n        className\n    ].filter(Boolean).join(\" \");\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-full\",\n        style: {\n            height\n        },\n        onKeyDownCapture: handleKeyDownCapture,\n        onPasteCapture: handlePasteCapture,\n        children: [\n            error ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mb-3 rounded-md border border-red-500/40 bg-red-500/10 px-3 py-2 text-sm text-red-200\",\n                children: error\n            }, void 0, false, {\n                fileName: \"/Users/alexandershubert/git/hbc_tsy_enhanced/hbc_web/components/hbc/HbcAgTable.tsx\",\n                lineNumber: 336,\n                columnNumber: 9\n            }, this) : null,\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: finalClassName,\n                style: {\n                    height: \"100%\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ag_grid_react__WEBPACK_IMPORTED_MODULE_3__.AgGridReact, {\n                    rowData: rowData,\n                    columnDefs: autoColumnDefs,\n                    defaultColDef: defaultColDef,\n                    gridOptions: mergedGridOptions,\n                    loading: loading,\n                    onGridReady: (e)=>{\n                        gridApiRef.current = e.api;\n                        onGridReady === null || onGridReady === void 0 ? void 0 : onGridReady(e);\n                    },\n                    onFilterChanged: onFilterChanged,\n                    onSortChanged: onSortChanged,\n                    onSelectionChanged: onSelectionChanged,\n                    onCellClicked: onCellClicked,\n                    onCellDoubleClicked: onCellDoubleClicked,\n                    onCellKeyDown: handleCellKeyDown,\n                    getRowId: rowIdField ? (p)=>{\n                        var _p_data;\n                        const raw = (_p_data = p.data) === null || _p_data === void 0 ? void 0 : _p_data[rowIdField];\n                        if (typeof raw === \"string\" && raw.length) return raw;\n                        if (typeof raw === \"number\") return String(raw);\n                        return JSON.stringify(p.data);\n                    } : undefined\n                }, void 0, false, {\n                    fileName: \"/Users/alexandershubert/git/hbc_tsy_enhanced/hbc_web/components/hbc/HbcAgTable.tsx\",\n                    lineNumber: 342,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/alexandershubert/git/hbc_tsy_enhanced/hbc_web/components/hbc/HbcAgTable.tsx\",\n                lineNumber: 341,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/alexandershubert/git/hbc_tsy_enhanced/hbc_web/components/hbc/HbcAgTable.tsx\",\n        lineNumber: 329,\n        columnNumber: 5\n    }, this);\n}\n_s(HbcAgTable, \"DrDoD2M1j1XQLsNZvbq+A08+uL0=\");\n_c = HbcAgTable;\nvar _c;\n$RefreshReg$(_c, \"HbcAgTable\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvaGJjL0hiY0FnVGFibGUudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEsaUJBQWlCOzs7QUFHNEI7QUFDUTtBQUVpQjtBQU0zQjtBQUVKO0FBRXZDLElBQUlLLG1CQUFtQjtBQUN2QixJQUFJLENBQUNBLGtCQUFrQjtJQUNyQkosNkRBQWNBLENBQUNLLGVBQWUsQ0FBQztRQUFDTixpRUFBa0JBO0tBQUM7SUFDbkRLLG1CQUFtQjtBQUNyQjtBQXFCTyxTQUFTRSxXQUE4QyxLQWlCekM7UUFqQnlDLEVBQzVEQyxPQUFPLEVBQ1BDLFVBQVUsRUFDVkMsU0FBUyxFQUNUQyxTQUFTLE1BQU0sRUFDZkMsT0FBTyxFQUNQQyxLQUFLLEVBQ0xDLFdBQVcsRUFDWEMsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLGVBQWUsRUFDZkMsYUFBYSxFQUNiQyxrQkFBa0IsRUFDbEJDLGFBQWEsRUFDYkMsbUJBQW1CLEVBQ25CQyxhQUFhLEVBQ2JDLGFBQWEsRUFDTSxHQWpCeUM7O0lBa0I1RCxNQUFNQyxhQUFhcEIsNkNBQU1BLENBQW9CO0lBQzdDLE1BQU1xQiwwQkFBMEJ0Qiw4Q0FBT0EsQ0FBQztRQUN0QyxNQUFNdUIsTUFBTSxJQUFJQztRQUNoQixLQUFLLE1BQU1DLE9BQU9uQix1QkFBQUEsd0JBQUFBLGFBQWMsRUFBRSxDQUFFO2dCQUNuQm1CO1lBQWYsTUFBTUMsUUFBU0QsQ0FBQUEsYUFBQUEsSUFBSUMsS0FBSyxjQUFURCx3QkFBQUEsYUFBYUEsSUFBSUUsS0FBSztZQUNyQyxJQUFJLENBQUNELE9BQU87WUFDWkgsSUFBSUssR0FBRyxDQUFDRixPQUFPRCxJQUFJSSxNQUFNO1FBQzNCO1FBQ0EsT0FBT047SUFDVCxHQUFHO1FBQUNqQjtLQUFXO0lBRWYsZUFBZXdCLFNBQVNDLElBQVk7UUFDbEMsSUFBSTtnQkFDRUMsc0JBQUFBO1lBQUosS0FBSUEsYUFBQUEsdUJBQUFBLGtDQUFBQSx1QkFBQUEsV0FBV0Ms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TUFBTSxDQUFDc0gsU0FDUEMsSUFBSSxDQUFDO0lBRVIscUJBQ0UsOERBQUNDO1FBQ0M5SSxXQUFVO1FBQ1ZpQyxPQUFPO1lBQUVoQztRQUFPO1FBQ2hCOEksa0JBQWtCeEM7UUFDbEJ5QyxnQkFBZ0JsQzs7WUFFZjNHLHNCQUNDLDhEQUFDMkk7Z0JBQUk5SSxXQUFVOzBCQUNaRzs7Ozs7dUJBRUQ7MEJBRUosOERBQUMySTtnQkFBSTlJLFdBQVcySTtnQkFBZ0IxRyxPQUFPO29CQUFFaEMsUUFBUTtnQkFBTzswQkFDdEQsNEVBQUNULHNEQUFXQTtvQkFDVk0sU0FBU0E7b0JBQ1RDLFlBQVl3SDtvQkFDWkcsZUFBZUE7b0JBQ2Z0SCxhQUFhNEg7b0JBQ2I5SCxTQUFTQTtvQkFDVEksYUFBYSxDQUFDb0M7d0JBQ1o1QixXQUFXcUQsT0FBTyxHQUFHekIsRUFBRXdCLEdBQUc7d0JBQzFCNUQsd0JBQUFBLGtDQUFBQSxZQUFjb0M7b0JBQ2hCO29CQUNBbkMsaUJBQWlCQTtvQkFDakJDLGVBQWVBO29CQUNmQyxvQkFBb0JBO29CQUNwQkMsZUFBZUE7b0JBQ2ZDLHFCQUFxQkE7b0JBQ3JCQyxlQUFlNkI7b0JBQ2Z3RyxVQUNFNUksYUFDSSxDQUFDNkk7NEJBQ2FBO3dCQUFaLE1BQU1DLE9BQU1ELFVBQUFBLEVBQUU1QixJQUFJLGNBQU40Qiw4QkFBQUEsT0FBUSxDQUFDN0ksV0FBVzt3QkFDaEMsSUFBSSxPQUFPOEksUUFBUSxZQUFZQSxJQUFJdEYsTUFBTSxFQUFFLE9BQU9zRjt3QkFDbEQsSUFBSSxPQUFPQSxRQUFRLFVBQVUsT0FBTzlGLE9BQU84Rjt3QkFDM0MsT0FBT0MsS0FBS0MsU0FBUyxDQUFDSCxFQUFFNUIsSUFBSTtvQkFDOUIsSUFDQWxFOzs7Ozs7Ozs7Ozs7Ozs7OztBQU1oQjtHQTFVZ0J2RDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2hiYy9IYmNBZ1RhYmxlLnRzeD8yYmUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEhiY0FnVGFibGUudHN4XG5cInVzZSBjbGllbnRcIlxuXG5pbXBvcnQgXCJhZy1ncmlkLWNvbW11bml0eS9zdHlsZXMvYWctZ3JpZC5jc3NcIlxuaW1wb3J0IFwiYWctZ3JpZC1jb21tdW5pdHkvc3R5bGVzL2FnLXRoZW1lLXF1YXJ0ei5jc3NcIlxuXG5pbXBvcnQgeyBBbGxDb21tdW5pdHlNb2R1bGUsIE1vZHVsZVJlZ2lzdHJ5IH0gZnJvbSBcImFnLWdyaWQtY29tbXVuaXR5XCJcbmltcG9ydCB0eXBlIHsgQ29sRGVmLCBHcmlkQXBpLCBHcmlkT3B0aW9ucyB9IGZyb20gXCJhZy1ncmlkLWNvbW11bml0eVwiXG5pbXBvcnQgdHlwZSB7IENlbGxDbGlja2VkRXZlbnQsIENlbGxEb3VibGVDbGlja2VkRXZlbnQgfSBmcm9tIFwiYWctZ3JpZC1jb21tdW5pdHlcIlxuaW1wb3J0IHR5cGUgeyBDZWxsS2V5RG93bkV2ZW50IH0gZnJvbSBcImFnLWdyaWQtY29tbXVuaXR5XCJcbmltcG9ydCB0eXBlIHsgRmlsdGVyQ2hhbmdlZEV2ZW50LCBHcmlkUmVhZHlFdmVudCwgU29ydENoYW5nZWRFdmVudCB9IGZyb20gXCJhZy1ncmlkLWNvbW11bml0eVwiXG5pbXBvcnQgdHlwZSB7IFNlbGVjdGlvbkNoYW5nZWRFdmVudCB9IGZyb20gXCJhZy1ncmlkLWNvbW11bml0eVwiXG5pbXBvcnQgeyBBZ0dyaWRSZWFjdCB9IGZyb20gXCJhZy1ncmlkLXJlYWN0XCJcbmltcG9ydCB0eXBlIHsgS2V5Ym9hcmRFdmVudCBhcyBSZWFjdEtleWJvYXJkRXZlbnQgfSBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCJcblxubGV0IGFnR3JpZFJlZ2lzdGVyZWQgPSBmYWxzZVxuaWYgKCFhZ0dyaWRSZWdpc3RlcmVkKSB7XG4gIE1vZHVsZVJlZ2lzdHJ5LnJlZ2lzdGVyTW9kdWxlcyhbQWxsQ29tbXVuaXR5TW9kdWxlXSlcbiAgYWdHcmlkUmVnaXN0ZXJlZCA9IHRydWVcbn1cblxuZXhwb3J0IHR5cGUgSGJjQWdUYWJsZVByb3BzPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4gPSB7XG4gIHJvd0RhdGE6IFRbXVxuICBjb2x1bW5EZWZzPzogQ29sRGVmPFQ+W11cbiAgY2xhc3NOYW1lPzogc3RyaW5nXG4gIGhlaWdodD86IG51bWJlciB8IHN0cmluZ1xuICBsb2FkaW5nPzogYm9vbGVhblxuICBlcnJvcj86IHN0cmluZyB8IG51bGxcbiAgZ3JpZE9wdGlvbnM/OiBHcmlkT3B0aW9uczxUPlxuICByb3dJZEZpZWxkPzogRXh0cmFjdDxrZXlvZiBULCBzdHJpbmc+XG4gIG9uR3JpZFJlYWR5PzogKGV2ZW50OiBHcmlkUmVhZHlFdmVudDxUPikgPT4gdm9pZFxuICBvbkZpbHRlckNoYW5nZWQ/OiAoZXZlbnQ6IEZpbHRlckNoYW5nZWRFdmVudDxUPikgPT4gdm9pZFxuICBvblNvcnRDaGFuZ2VkPzogKGV2ZW50OiBTb3J0Q2hhbmdlZEV2ZW50PFQ+KSA9PiB2b2lkXG4gIG9uU2VsZWN0aW9uQ2hhbmdlZD86IChldmVudDogU2VsZWN0aW9uQ2hhbmdlZEV2ZW50PFQ+KSA9PiB2b2lkXG4gIG9uQ2VsbENsaWNrZWQ/OiAoZXZlbnQ6IENlbGxDbGlja2VkRXZlbnQ8VD4pID0+IHZvaWRcbiAgb25DZWxsRG91YmxlQ2xpY2tlZD86IChldmVudDogQ2VsbERvdWJsZUNsaWNrZWRFdmVudDxUPikgPT4gdm9pZFxuICBvbkNlbGxLZXlEb3duPzogKGV2ZW50OiBDZWxsS2V5RG93bkV2ZW50PFQ+KSA9PiB2b2lkXG4gIG9uRmlsdGVyUGFzdGU/OiAoY29sSWQ6IHN0cmluZykgPT4gdm9pZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gSGJjQWdUYWJsZTxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KHtcbiAgcm93RGF0YSxcbiAgY29sdW1uRGVmcyxcbiAgY2xhc3NOYW1lLFxuICBoZWlnaHQgPSBcIjEwMCVcIixcbiAgbG9hZGluZyxcbiAgZXJyb3IsXG4gIGdyaWRPcHRpb25zLFxuICByb3dJZEZpZWxkLFxuICBvbkdyaWRSZWFkeSxcbiAgb25GaWx0ZXJDaGFuZ2VkLFxuICBvblNvcnRDaGFuZ2VkLFxuICBvblNlbGVjdGlvbkNoYW5nZWQsXG4gIG9uQ2VsbENsaWNrZWQsXG4gIG9uQ2VsbERvdWJsZUNsaWNrZWQsXG4gIG9uQ2VsbEtleURvd24sXG4gIG9uRmlsdGVyUGFzdGUsXG59OiBIYmNBZ1RhYmxlUHJvcHM8VD4pIHtcbiAgY29uc3QgZ3JpZEFwaVJlZiA9IHVzZVJlZjxHcmlkQXBpPFQ+IHwgbnVsbD4obnVsbClcbiAgY29uc3QgY29sdW1uRmlsdGVyVHlwZUJ5Q29sSWQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBtYXAgPSBuZXcgTWFwPHN0cmluZywgdW5rbm93bj4oKVxuICAgIGZvciAoY29uc3QgZGVmIG9mIGNvbHVtbkRlZnMgPz8gW10pIHtcbiAgICAgIGNvbnN0IGNvbElkID0gKGRlZi5jb2xJZCA/PyBkZWYuZmllbGQpIGFzIHN0cmluZyB8IHVuZGVmaW5lZFxuICAgICAgaWYgKCFjb2xJZCkgY29udGludWVcbiAgICAgIG1hcC5zZXQoY29sSWQsIGRlZi5maWx0ZXIpXG4gICAgfVxuICAgIHJldHVybiBtYXBcbiAgfSwgW2NvbHVtbkRlZnNdKVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGNvcHlUZXh0KHRleHQ6IHN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBpZiAobmF2aWdhdG9yPy5jbGlwYm9hcmQ/LndyaXRlVGV4dCkge1xuICAgICAgICBhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIGlnbm9yZSBhbmQgZmFsbCBiYWNrXG4gICAgfVxuXG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIilcbiAgICBlbC52YWx1ZSA9IHRleHRcbiAgICBlbC5zZXRBdHRyaWJ1dGUoXCJyZWFkb25seVwiLCBcInRydWVcIilcbiAgICBlbC5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIlxuICAgIGVsLnN0eWxlLnRvcCA9IFwiLTk5OTlweFwiXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbClcbiAgICBlbC5zZWxlY3QoKVxuICAgIGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiY29weVwiKVxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVDZWxsS2V5RG93bihlOiBDZWxsS2V5RG93bkV2ZW50PFQ+KSB7XG4gICAgb25DZWxsS2V5RG93bj8uKGUpXG5cbiAgICBjb25zdCBldiA9IGUuZXZlbnQgYXMgS2V5Ym9hcmRFdmVudCB8IHVuZGVmaW5lZFxuICAgIGlmICghZXYpIHJldHVyblxuXG4gICAgY29uc3Qga2V5ID0gZXYua2V5Py50b0xvd2VyQ2FzZSgpXG4gICAgY29uc3QgaXNDb3B5ID0gKGV2Lm1ldGFLZXkgfHwgZXYuY3RybEtleSkgJiYga2V5ID09PSBcImNcIiAmJiAhZXYuc2hpZnRLZXkgJiYgIWV2LmFsdEtleVxuICAgIGlmICghaXNDb3B5KSByZXR1cm5cblxuICAgIGNvbnN0IHZhbHVlID0gZS52YWx1ZVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgICBjb25zdCB0ZXh0ID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUgOiBTdHJpbmcodmFsdWUpXG5cbiAgICBldi5wcmV2ZW50RGVmYXVsdCgpXG4gICAgdm9pZCBjb3B5VGV4dCh0ZXh0KVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZEZsb2F0aW5nRmlsdGVyQ29sdW1uSWQodGFyZ2V0OiBFdmVudFRhcmdldCB8IG51bGwpOiBzdHJpbmcgfCBudWxsIHtcbiAgICBpZiAoIXRhcmdldCB8fCAhKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkgcmV0dXJuIG51bGxcbiAgICBjb25zdCBkaXJlY3QgPSB0YXJnZXQuY2xvc2VzdChcIltjb2wtaWRdXCIpPy5nZXRBdHRyaWJ1dGUoXCJjb2wtaWRcIilcbiAgICBpZiAoZGlyZWN0ICYmIGRpcmVjdC5sZW5ndGgpIHJldHVybiBkaXJlY3RcblxuICAgIGNvbnN0IGZsb2F0aW5nID0gdGFyZ2V0LmNsb3Nlc3QoXCIuYWctZmxvYXRpbmctZmlsdGVyXCIpXG4gICAgaWYgKCFmbG9hdGluZykgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IGhlYWRlckNlbGwgPSB0YXJnZXQuY2xvc2VzdChcIi5hZy1oZWFkZXItY2VsbFwiKVxuICAgIGNvbnN0IGNvbElkID0gaGVhZGVyQ2VsbD8uZ2V0QXR0cmlidXRlKFwiY29sLWlkXCIpXG4gICAgcmV0dXJuIGNvbElkICYmIGNvbElkLmxlbmd0aCA/IGNvbElkIDogbnVsbFxuICB9XG5cbiAgZnVuY3Rpb24gc2V0RXF1YWxzRm9yVGV4dEZpbHRlcihjb2xJZDogc3RyaW5nLCBmaWx0ZXJUZXh0Pzogc3RyaW5nKSB7XG4gICAgY29uc3QgYXBpID0gZ3JpZEFwaVJlZi5jdXJyZW50XG4gICAgaWYgKCFhcGkpIHJldHVyblxuXG4gICAgY29uc3QgbW9kZWwgPSAoYXBpLmdldEZpbHRlck1vZGVsKCkgYXMgUmVjb3JkPHN0cmluZywgYW55PikgPz8ge31cbiAgICBjb25zdCBleGlzdGluZyA9IG1vZGVsW2NvbElkXVxuICAgIGNvbnN0IG5leHRUZXh0ID0gdHlwZW9mIGZpbHRlclRleHQgPT09IFwic3RyaW5nXCIgPyBmaWx0ZXJUZXh0IDogZXhpc3Rpbmc/LmZpbHRlclxuICAgIGlmICh0eXBlb2YgbmV4dFRleHQgIT09IFwic3RyaW5nXCIpIHJldHVyblxuICAgIGNvbnN0IHRyaW1tZWQgPSBuZXh0VGV4dC50cmltKClcbiAgICBpZiAoIXRyaW1tZWQpIHJldHVyblxuXG4gICAgY29uc3QgZXhpc3RpbmdUeXBlID0gZXhpc3Rpbmc/LnR5cGUgPyBTdHJpbmcoZXhpc3RpbmcudHlwZSkudG9Mb3dlckNhc2UoKSA6IFwiXCJcbiAgICBjb25zdCBleGlzdGluZ1ZhbHVlID0gdHlwZW9mIGV4aXN0aW5nPy5maWx0ZXIgPT09IFwic3RyaW5nXCIgPyBleGlzdGluZy5maWx0ZXIudHJpbSgpIDogXCJcIlxuICAgIGlmIChleGlzdGluZ1R5cGUgPT09IFwiZXF1YWxzXCIgJiYgZXhpc3RpbmdWYWx1ZSA9PT0gdHJpbW1lZCkgcmV0dXJuXG5cbiAgICBhcGkuc2V0RmlsdGVyTW9kZWwoe1xuICAgICAgLi4ubW9kZWwsXG4gICAgICBbY29sSWRdOiB7XG4gICAgICAgIC4uLihleGlzdGluZyA/PyB7fSksXG4gICAgICAgIGZpbHRlclR5cGU6IChleGlzdGluZz8uZmlsdGVyVHlwZSBhcyBzdHJpbmcgfCB1bmRlZmluZWQpID8/IFwidGV4dFwiLFxuICAgICAgICB0eXBlOiBcImVxdWFsc1wiLFxuICAgICAgICBmaWx0ZXI6IHRyaW1tZWQsXG4gICAgICB9LFxuICAgIH0pXG4gICAgYXBpLm9uRmlsdGVyQ2hhbmdlZD8uKClcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRGF0ZUZyb21UZXh0KGlucHV0OiBzdHJpbmcpIHtcbiAgICBjb25zdCB0ZXh0ID0gaW5wdXQudHJpbSgpXG4gICAgaWYgKCF0ZXh0KSByZXR1cm4gbnVsbFxuXG4gICAgY29uc3QgaXNvTWF0Y2ggPSAvXihcXGR7NH0tXFxkezJ9LVxcZHsyfSkvLmV4ZWModGV4dClcbiAgICBpZiAoaXNvTWF0Y2gpIHJldHVybiBpc29NYXRjaFsxXVxuXG4gICAgY29uc3QgbXMgPSBEYXRlLnBhcnNlKHRleHQpXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobXMpKSByZXR1cm4gbnVsbFxuXG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKG1zKVxuICAgIGNvbnN0IHl5eXkgPSBTdHJpbmcoZC5nZXRGdWxsWWVhcigpKS5wYWRTdGFydCg0LCBcIjBcIilcbiAgICBjb25zdCBtbSA9IFN0cmluZyhkLmdldE1vbnRoKCkgKyAxKS5wYWRTdGFydCgyLCBcIjBcIilcbiAgICBjb25zdCBkZCA9IFN0cmluZyhkLmdldERhdGUoKSkucGFkU3RhcnQoMiwgXCIwXCIpXG4gICAgcmV0dXJuIGAke3l5eXl9LSR7bW19LSR7ZGR9YFxuICB9XG5cbiAgZnVuY3Rpb24gc2V0RXF1YWxzRm9yRGF0ZUZpbHRlcihjb2xJZDogc3RyaW5nLCBmaWx0ZXJUZXh0Pzogc3RyaW5nKSB7XG4gICAgY29uc3QgYXBpID0gZ3JpZEFwaVJlZi5jdXJyZW50XG4gICAgaWYgKCFhcGkpIHJldHVyblxuXG4gICAgY29uc3QgbW9kZWwgPSAoYXBpLmdldEZpbHRlck1vZGVsKCkgYXMgUmVjb3JkPHN0cmluZywgYW55PikgPz8ge31cbiAgICBjb25zdCBleGlzdGluZyA9IG1vZGVsW2NvbElkXVxuXG4gICAgY29uc3QgbmV4dFRleHQgPSB0eXBlb2YgZmlsdGVyVGV4dCA9PT0gXCJzdHJpbmdcIiA/IGZpbHRlclRleHQgOiBleGlzdGluZz8uZGF0ZUZyb21cbiAgICBpZiAodHlwZW9mIG5leHRUZXh0ICE9PSBcInN0cmluZ1wiKSByZXR1cm5cblxuICAgIGNvbnN0IGRhdGVGcm9tID0gcGFyc2VEYXRlRnJvbVRleHQobmV4dFRleHQpXG4gICAgaWYgKCFkYXRlRnJvbSkgcmV0dXJuXG5cbiAgICBjb25zdCBleGlzdGluZ1R5cGUgPSBleGlzdGluZz8udHlwZSA/IFN0cmluZyhleGlzdGluZy50eXBlKS50b0xvd2VyQ2FzZSgpIDogXCJcIlxuICAgIGNvbnN0IGV4aXN0aW5nRGF0ZUZyb20gPSB0eXBlb2YgZXhpc3Rpbmc/LmRhdGVGcm9tID09PSBcInN0cmluZ1wiID8gZXhpc3RpbmcuZGF0ZUZyb20udHJpbSgpIDogXCJcIlxuICAgIGlmIChleGlzdGluZ1R5cGUgPT09IFwiZXF1YWxzXCIgJiYgZXhpc3RpbmdEYXRlRnJvbSA9PT0gZGF0ZUZyb20pIHJldHVyblxuXG4gICAgYXBpLnNldEZpbHRlck1vZGVsKHtcbiAgICAgIC4uLm1vZGVsLFxuICAgICAgW2NvbElkXToge1xuICAgICAgICAuLi4oZXhpc3RpbmcgPz8ge30pLFxuICAgICAgICBmaWx0ZXJUeXBlOiBcImRhdGVcIixcbiAgICAgICAgdHlwZTogXCJlcXVhbHNcIixcbiAgICAgICAgZGF0ZUZyb20sXG4gICAgICB9LFxuICAgIH0pXG4gICAgYXBpLm9uRmlsdGVyQ2hhbmdlZD8uKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFByZWZlcnJlZEZpbHRlclR5cGUoY29sSWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGFwaSA9IGdyaWRBcGlSZWYuY3VycmVudFxuICAgIGNvbnN0IG1vZGVsID0gKGFwaT8uZ2V0RmlsdGVyTW9kZWwoKSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA/PyB7fVxuICAgIGNvbnN0IGV4aXN0aW5nID0gbW9kZWxbY29sSWRdXG4gICAgY29uc3QgZXhpc3RpbmdGaWx0ZXJUeXBlID0gdHlwZW9mIGV4aXN0aW5nPy5maWx0ZXJUeXBlID09PSBcInN0cmluZ1wiID8gZXhpc3RpbmcuZmlsdGVyVHlwZSA6IHVuZGVmaW5lZFxuICAgIGlmIChleGlzdGluZ0ZpbHRlclR5cGUpIHJldHVybiBleGlzdGluZ0ZpbHRlclR5cGVcblxuICAgIGNvbnN0IGNvbEZpbHRlciA9IGNvbHVtbkZpbHRlclR5cGVCeUNvbElkLmdldChjb2xJZClcbiAgICBpZiAoY29sRmlsdGVyID09PSBcImFnRGF0ZUNvbHVtbkZpbHRlclwiKSByZXR1cm4gXCJkYXRlXCJcbiAgICBpZiAoY29sRmlsdGVyID09PSBcImFnTnVtYmVyQ29sdW1uRmlsdGVyXCIpIHJldHVybiBcIm51bWJlclwiXG4gICAgcmV0dXJuIFwidGV4dFwiXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVLZXlEb3duQ2FwdHVyZShldjogUmVhY3RLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3Qga2V5ID0gZXYua2V5Py50b0xvd2VyQ2FzZSgpXG4gICAgY29uc3QgaXNDb3B5ID0gKGV2Lm1ldGFLZXkgfHwgZXYuY3RybEtleSkgJiYga2V5ID09PSBcImNcIiAmJiAhZXYuc2hpZnRLZXkgJiYgIWV2LmFsdEtleVxuICAgIGNvbnN0IGlzUGFzdGUgPSAoZXYubWV0YUtleSB8fCBldi5jdHJsS2V5KSAmJiBrZXkgPT09IFwidlwiICYmICFldi5zaGlmdEtleSAmJiAhZXYuYWx0S2V5XG5cbiAgICBpZiAoIWlzQ29weSAmJiAhaXNQYXN0ZSkgcmV0dXJuXG5cbiAgICBjb25zdCBjb2xJZCA9IGZpbmRGbG9hdGluZ0ZpbHRlckNvbHVtbklkKGV2LnRhcmdldClcbiAgICBpZiAoIWNvbElkKSB7XG4gICAgICBpZiAoaXNDb3B5KSB7XG4gICAgICAgIGNvbnN0IHRleHQgPSBnZXRGb2N1c2VkQ2VsbFRleHQoKVxuICAgICAgICBpZiAoIXRleHQpIHJldHVyblxuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHZvaWQgY29weVRleHQodGV4dClcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc1Bhc3RlKSB7XG4gICAgICBvbkZpbHRlclBhc3RlPy4oY29sSWQpXG4gICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gZXYudGFyZ2V0XG4gICAgICAgIGNvbnN0IHZhbHVlID1cbiAgICAgICAgICBlbCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgfHwgZWwgaW5zdGFuY2VvZiBIVE1MVGV4dEFyZWFFbGVtZW50ID8gZWwudmFsdWUgOiB1bmRlZmluZWRcbiAgICAgICAgY29uc3QgZmlsdGVyVHlwZSA9IGdldFByZWZlcnJlZEZpbHRlclR5cGUoY29sSWQpXG4gICAgICAgIGlmIChmaWx0ZXJUeXBlID09PSBcImRhdGVcIikge1xuICAgICAgICAgIHNldEVxdWFsc0ZvckRhdGVGaWx0ZXIoY29sSWQsIHZhbHVlKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHNldEVxdWFsc0ZvclRleHRGaWx0ZXIoY29sSWQsIHZhbHVlKVxuICAgICAgfSwgNDApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXNDb3B5KSB7XG4gICAgICBjb25zdCB0ZXh0ID0gZ2V0Rm9jdXNlZENlbGxUZXh0KClcbiAgICAgIGlmICghdGV4dCkgcmV0dXJuXG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICB2b2lkIGNvcHlUZXh0KHRleHQpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlUGFzdGVDYXB0dXJlKGV2OiBSZWFjdC5DbGlwYm9hcmRFdmVudCkge1xuICAgIGNvbnN0IGNvbElkID0gZmluZEZsb2F0aW5nRmlsdGVyQ29sdW1uSWQoZXYudGFyZ2V0KVxuICAgIGlmICghY29sSWQpIHJldHVyblxuXG4gICAgb25GaWx0ZXJQYXN0ZT8uKGNvbElkKVxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnN0IGVsID0gZXYudGFyZ2V0XG4gICAgICBjb25zdCB2YWx1ZSA9IGVsIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCB8fCBlbCBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnQgPyBlbC52YWx1ZSA6IHVuZGVmaW5lZFxuICAgICAgY29uc3QgZmlsdGVyVHlwZSA9IGdldFByZWZlcnJlZEZpbHRlclR5cGUoY29sSWQpXG4gICAgICBpZiAoZmlsdGVyVHlwZSA9PT0gXCJkYXRlXCIpIHtcbiAgICAgICAgc2V0RXF1YWxzRm9yRGF0ZUZpbHRlcihjb2xJZCwgdmFsdWUpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgc2V0RXF1YWxzRm9yVGV4dEZpbHRlcihjb2xJZCwgdmFsdWUpXG4gICAgfSwgNDApXG4gIH1cblxuICBmdW5jdGlvbiBnZXRGb2N1c2VkQ2VsbFRleHQoKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgY29uc3QgYXBpID0gZ3JpZEFwaVJlZi5jdXJyZW50XG4gICAgaWYgKCFhcGkpIHJldHVybiBudWxsXG5cbiAgICBjb25zdCBmb2N1c2VkID0gYXBpLmdldEZvY3VzZWRDZWxsPy4oKVxuICAgIGlmICghZm9jdXNlZCkgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IHJvd05vZGUgPSBhcGkuZ2V0RGlzcGxheWVkUm93QXRJbmRleD8uKGZvY3VzZWQucm93SW5kZXgpXG4gICAgY29uc3QgY29sSWQgPSBmb2N1c2VkLmNvbHVtbj8uZ2V0Q29sSWQ/LigpXG4gICAgaWYgKCFyb3dOb2RlIHx8ICFjb2xJZCkgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IHZhbHVlID0gKHJvd05vZGUuZGF0YSBhcyBhbnkpPy5bY29sSWRdXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBudWxsXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogU3RyaW5nKHZhbHVlKVxuICB9XG5cbiAgY29uc3QgYXV0b0NvbHVtbkRlZnMgPSB1c2VNZW1vPENvbERlZjxUPltdPigoKSA9PiB7XG4gICAgaWYgKGNvbHVtbkRlZnMgJiYgY29sdW1uRGVmcy5sZW5ndGgpIHJldHVybiBjb2x1bW5EZWZzXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHJvd0RhdGE/LlswXSA/PyB7fSlcbiAgICByZXR1cm4ga2V5cy5tYXAoKGZpZWxkKSA9PiAoeyBmaWVsZCB9KSkgYXMgQ29sRGVmPFQ+W11cbiAgfSwgW2NvbHVtbkRlZnMsIHJvd0RhdGFdKVxuXG4gIGNvbnN0IGRlZmF1bHRDb2xEZWYgPSB1c2VNZW1vPENvbERlZjxUPj4oXG4gICAgKCkgPT4gKHtcbiAgICAgIHJlc2l6YWJsZTogdHJ1ZSxcbiAgICAgIHNvcnRhYmxlOiB0cnVlLFxuICAgICAgdW5Tb3J0SWNvbjogdHJ1ZSxcbiAgICAgIGZpbHRlcjogdHJ1ZSxcbiAgICAgIGZsb2F0aW5nRmlsdGVyOiB0cnVlLFxuICAgICAgbWluV2lkdGg6IDE0MCxcbiAgICB9KSxcbiAgICBbXVxuICApXG5cbiAgY29uc3QgbWVyZ2VkR3JpZE9wdGlvbnMgPSB1c2VNZW1vPEdyaWRPcHRpb25zPFQ+PihcbiAgICAoKSA9PiAoe1xuICAgICAgdGhlbWU6IFwibGVnYWN5XCIsXG4gICAgICBhbmltYXRlUm93czogdHJ1ZSxcbiAgICAgIHJvd1NlbGVjdGlvbjogXCJzaW5nbGVcIixcbiAgICAgIHN1cHByZXNzQ2VsbEZvY3VzOiBmYWxzZSxcbiAgICAgIHBhZ2luYXRpb246IGZhbHNlLFxuXG4gICAgICBhbHdheXNTaG93SG9yaXpvbnRhbFNjcm9sbDogdHJ1ZSxcbiAgICAgIHN1cHByZXNzSG9yaXpvbnRhbFNjcm9sbDogZmFsc2UsXG4gICAgICBzdXBwcmVzc1Jvd0NsaWNrU2VsZWN0aW9uOiB0cnVlLFxuICAgICAgZW5hYmxlQ2VsbFRleHRTZWxlY3Rpb246IHRydWUsXG4gICAgICBlbnN1cmVEb21PcmRlcjogdHJ1ZSxcblxuICAgICAgLi4uKGdyaWRPcHRpb25zID8/IHt9KSxcbiAgICB9KSxcbiAgICBbZ3JpZE9wdGlvbnNdXG4gIClcblxuICBjb25zdCBmaW5hbENsYXNzTmFtZSA9IFtcbiAgICBcImhiYy1hZy1ncmlkIGFnLXRoZW1lLXF1YXJ0ei1kYXJrIHctZnVsbCByb3VuZGVkLWxnIGJvcmRlciBib3JkZXItW2NvbG9yOnZhcigtLWNvbG9yLWJvcmRlcildIGJnLVtjb2xvcjp2YXIoLS1jb2xvci1jYXJkKV1cIixcbiAgICBjbGFzc05hbWUsXG4gIF1cbiAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgLmpvaW4oXCIgXCIpXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9XCJ3LWZ1bGxcIlxuICAgICAgc3R5bGU9e3sgaGVpZ2h0IH19XG4gICAgICBvbktleURvd25DYXB0dXJlPXtoYW5kbGVLZXlEb3duQ2FwdHVyZX1cbiAgICAgIG9uUGFzdGVDYXB0dXJlPXtoYW5kbGVQYXN0ZUNhcHR1cmV9XG4gICAgPlxuICAgICAge2Vycm9yID8gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1iLTMgcm91bmRlZC1tZCBib3JkZXIgYm9yZGVyLXJlZC01MDAvNDAgYmctcmVkLTUwMC8xMCBweC0zIHB5LTIgdGV4dC1zbSB0ZXh0LXJlZC0yMDBcIj5cbiAgICAgICAgICB7ZXJyb3J9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKSA6IG51bGx9XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtmaW5hbENsYXNzTmFtZX0gc3R5bGU9e3sgaGVpZ2h0OiBcIjEwMCVcIiB9fT5cbiAgICAgICAgPEFnR3JpZFJlYWN0PFQ+XG4gICAgICAgICAgcm93RGF0YT17cm93RGF0YX1cbiAgICAgICAgICBjb2x1bW5EZWZzPXthdXRvQ29sdW1uRGVmc31cbiAgICAgICAgICBkZWZhdWx0Q29sRGVmPXtkZWZhdWx0Q29sRGVmfVxuICAgICAgICAgIGdyaWRPcHRpb25zPXttZXJnZWRHcmlkT3B0aW9uc31cbiAgICAgICAgICBsb2FkaW5nPXtsb2FkaW5nfVxuICAgICAgICAgIG9uR3JpZFJlYWR5PXsoZSkgPT4ge1xuICAgICAgICAgICAgZ3JpZEFwaVJlZi5jdXJyZW50ID0gZS5hcGlcbiAgICAgICAgICAgIG9uR3JpZFJlYWR5Py4oZSlcbiAgICAgICAgICB9fVxuICAgICAgICAgIG9uRmlsdGVyQ2hhbmdlZD17b25GaWx0ZXJDaGFuZ2VkfVxuICAgICAgICAgIG9uU29ydENoYW5nZWQ9e29uU29ydENoYW5nZWR9XG4gICAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2VkPXtvblNlbGVjdGlvbkNoYW5nZWR9XG4gICAgICAgICAgb25DZWxsQ2xpY2tlZD17b25DZWxsQ2xpY2tlZH1cbiAgICAgICAgICBvbkNlbGxEb3VibGVDbGlja2VkPXtvbkNlbGxEb3VibGVDbGlja2VkfVxuICAgICAgICAgIG9uQ2VsbEtleURvd249e2hhbmRsZUNlbGxLZXlEb3dufVxuICAgICAgICAgIGdldFJvd0lkPXtcbiAgICAgICAgICAgIHJvd0lkRmllbGRcbiAgICAgICAgICAgICAgPyAocCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcmF3ID0gcC5kYXRhPy5bcm93SWRGaWVsZF1cbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmF3ID09PSBcInN0cmluZ1wiICYmIHJhdy5sZW5ndGgpIHJldHVybiByYXdcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmF3ID09PSBcIm51bWJlclwiKSByZXR1cm4gU3RyaW5nKHJhdylcbiAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwLmRhdGEpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG4iXSwibmFtZXMiOlsiQWxsQ29tbXVuaXR5TW9kdWxlIiwiTW9kdWxlUmVnaXN0cnkiLCJBZ0dyaWRSZWFjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJhZ0dyaWRSZWdpc3RlcmVkIiwicmVnaXN0ZXJNb2R1bGVzIiwiSGJjQWdUYWJsZSIsInJvd0RhdGEiLCJjb2x1bW5EZWZzIiwiY2xhc3NOYW1lIiwiaGVpZ2h0IiwibG9hZGluZyIsImVycm9yIiwiZ3JpZE9wdGlvbnMiLCJyb3dJZEZpZWxkIiwib25HcmlkUmVhZHkiLCJvbkZpbHRlckNoYW5nZWQiLCJvblNvcnRDaGFuZ2VkIiwib25TZWxlY3Rpb25DaGFuZ2VkIiwib25DZWxsQ2xpY2tlZCIsIm9uQ2VsbERvdWJsZUNsaWNrZWQiLCJvbkNlbGxLZXlEb3duIiwib25GaWx0ZXJQYXN0ZSIsImdyaWRBcGlSZWYiLCJjb2x1bW5GaWx0ZXJUeXBlQnlDb2xJZCIsIm1hcCIsIk1hcCIsImRlZiIsImNvbElkIiwiZmllbGQiLCJzZXQiLCJmaWx0ZXIiLCJjb3B5VGV4dCIsInRleHQiLCJuYXZpZ2F0b3IiLCJjbGlwYm9hcmQiLCJ3cml0ZVRleHQiLCJlbCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInZhbHVlIiwic2V0QXR0cmlidXRlIiwic3R5bGUiLCJwb3NpdGlvbiIsInRvcCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInNlbGVjdCIsImV4ZWNDb21tYW5kIiwicmVtb3ZlQ2hpbGQiLCJoYW5kbGVDZWxsS2V5RG93biIsImUiLCJldiIsImV2ZW50Iiwia2V5IiwidG9Mb3dlckNhc2UiLCJpc0NvcHkiLCJtZXRhS2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwiYWx0S2V5IiwidW5kZWZpbmVkIiwiU3RyaW5nIiwicHJldmVudERlZmF1bHQiLCJmaW5kRmxvYXRpbmdGaWx0ZXJDb2x1bW5JZCIsInRhcmdldCIsIkhUTUxFbGVtZW50IiwiZGlyZWN0IiwiY2xvc2VzdCIsImdldEF0dHJpYnV0ZSIsImxlbmd0aCIsImZsb2F0aW5nIiwiaGVhZGVyQ2VsbCIsInNldEVxdWFsc0ZvclRleHRGaWx0ZXIiLCJmaWx0ZXJUZXh0IiwiYXBpIiwiY3VycmVudCIsIm1vZGVsIiwiZ2V0RmlsdGVyTW9kZWwiLCJleGlzdGluZyIsIm5leHRUZXh0IiwidHJpbW1lZCIsInRyaW0iLCJleGlzdGluZ1R5cGUiLCJ0eXBlIiwiZXhpc3RpbmdWYWx1ZSIsInNldEZpbHRlck1vZGVsIiwiZmlsdGVyVHlwZSIsInBhcnNlRGF0ZUZyb21UZXh0IiwiaW5wdXQiLCJpc29NYXRjaCIsImV4ZWMiLCJtcyIsIkRhdGUiLCJwYXJzZSIsIk51bWJlciIsImlzRmluaXRlIiwiZCIsInl5eXkiLCJnZXRGdWxsWWVhciIsInBhZFN0YXJ0IiwibW0iLCJnZXRNb250aCIsImRkIiwiZ2V0RGF0ZSIsInNldEVxdWFsc0ZvckRhdGVGaWx0ZXIiLCJkYXRlRnJvbSIsImV4aXN0aW5nRGF0ZUZyb20iLCJnZXRQcmVmZXJyZWRGaWx0ZXJUeXBlIiwiZXhpc3RpbmdGaWx0ZXJUeXBlIiwiY29sRmlsdGVyIiwiZ2V0IiwiaGFuZGxlS2V5RG93bkNhcHR1cmUiLCJpc1Bhc3RlIiwiZ2V0Rm9jdXNlZENlbGxUZXh0Iiwid2luZG93Iiwic2V0VGltZW91dCIsIkhUTUxJbnB1dEVsZW1lbnQiLCJIVE1MVGV4dEFyZWFFbGVtZW50IiwiaGFuZGxlUGFzdGVDYXB0dXJlIiwiZm9jdXNlZCIsInJvd05vZGUiLCJnZXRGb2N1c2VkQ2VsbCIsImdldERpc3BsYXllZFJvd0F0SW5kZXgiLCJyb3dJbmRleCIsImNvbHVtbiIsImdldENvbElkIiwiZGF0YSIsImF1dG9Db2x1bW5EZWZzIiwia2V5cyIsIk9iamVjdCIsImRlZmF1bHRDb2xEZWYiLCJyZXNpemFibGUiLCJzb3J0YWJsZSIsInVuU29ydEljb24iLCJmbG9hdGluZ0ZpbHRlciIsIm1pbldpZHRoIiwibWVyZ2VkR3JpZE9wdGlvbnMiLCJ0aGVtZSIsImFuaW1hdGVSb3dzIiwicm93U2VsZWN0aW9uIiwic3VwcHJlc3NDZWxsRm9jdXMiLCJwYWdpbmF0aW9uIiwiYWx3YXlzU2hvd0hvcml6b250YWxTY3JvbGwiLCJzdXBwcmVzc0hvcml6b250YWxTY3JvbGwiLCJzdXBwcmVzc1Jvd0NsaWNrU2VsZWN0aW9uIiwiZW5hYmxlQ2VsbFRleHRTZWxlY3Rpb24iLCJlbnN1cmVEb21PcmRlciIsImZpbmFsQ2xhc3NOYW1lIiwiQm9vbGVhbiIsImpvaW4iLCJkaXYiLCJvbktleURvd25DYXB0dXJlIiwib25QYXN0ZUNhcHR1cmUiLCJnZXRSb3dJZCIsInAiLCJyYXciLCJKU09OIiwic3RyaW5naWZ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/hbc/HbcAgTable.tsx\n"));

/***/ })

});