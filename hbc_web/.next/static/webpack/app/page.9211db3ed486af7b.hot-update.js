/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLHFDQUFxQyxxQkFBTSxpRkFBaUYscUJBQU0sa0VBQWtFLHFCQUFNLFdBQVcsbUJBQU8sQ0FBQyw0R0FBNEI7O0FBRXpQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/YjJjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/client-only/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/compiled/client-only/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {



/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxZQUFZLE9BQU8sZ0JBQWdCLG1CQUFtQixNQUFNLE1BQU0sNEJBQTRCLG1EQUFtRCwrQkFBK0IscURBQXFELFlBQVksSUFBSSxtQ0FBbUMsYUFBYSxLQUFLLG9CQUFvQixTQUFTLG1CQUFtQixJQUFJLHFDQUFxQyxlQUFlLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXVCLG1CQUFtQix1QkFBdUIsMkNBQTJDLGFBQWEsdUJBQXVCLElBQUksY0FBYyxTQUFTLElBQUksd0JBQXdCLFNBQVMsMEJBQTBCLDRCQUE0QixxQkFBcUIsdUJBQXVCLGdEQUFnRCxlQUFlLHVCQUF1QixJQUFJLFlBQVksU0FBUyxJQUFJLHNCQUFzQixTQUFTLHdCQUF3QixTQUFTLFlBQVksTUFBTSxTQUFTLDJCQUEyQixXQUFXLE9BQU8sUUFBUSxhQUFhLGNBQWMsS0FBSyxLQUFLLGFBQWEsY0FBYyxzQkFBc0IsTUFBTSxPQUFPLGtDQUFrQyxPQUFPLGVBQWUsU0FBUyxJQUFJLEtBQUssYUFBYSxNQUFNLFlBQVksS0FBSyxXQUFXLE9BQU8sUUFBUSxtQkFBbUIsdUJBQXVCLG9DQUFvQyx1QkFBdUIsWUFBWSxtQkFBbUIsS0FBSyxxQkFBcUIsc0JBQXNCLHFCQUFxQix5QkFBeUIsbUJBQW1CLFdBQVcsYUFBYSw4QkFBOEIsaUNBQWlDLGtCQUFrQixlQUFlLFNBQVMsVUFBVSxhQUFhLGNBQWMsaUJBQWlCLFVBQVUsbUJBQW1CLFlBQVksV0FBVyxzQkFBc0IsMEJBQTBCLFlBQVksdUJBQXVCLDJCQUEyQix3QkFBd0IsVUFBVSxzQkFBc0IscURBQXFELGlCQUFpQixXQUFXLG9CQUFvQixtREFBbUQsbUJBQW1CLFlBQVksU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Byb2Nlc3MvYnJvd3Nlci5qcz82NjhkIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciBlPXsyMjk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5leHBvcnRzPXt9O3ZhciByO3ZhciBuO2Z1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKXt0aHJvdyBuZXcgRXJyb3IoXCJjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9KGZ1bmN0aW9uKCl7dHJ5e2lmKHR5cGVvZiBzZXRUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtyPXNldFRpbWVvdXR9ZWxzZXtyPWRlZmF1bHRTZXRUaW1vdXR9fWNhdGNoKGUpe3I9ZGVmYXVsdFNldFRpbW91dH10cnl7aWYodHlwZW9mIGNsZWFyVGltZW91dD09PVwiZnVuY3Rpb25cIil7bj1jbGVhclRpbWVvdXR9ZWxzZXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fWNhdGNoKGUpe249ZGVmYXVsdENsZWFyVGltZW91dH19KSgpO2Z1bmN0aW9uIHJ1blRpbWVvdXQoZSl7aWYocj09PXNldFRpbWVvdXQpe3JldHVybiBzZXRUaW1lb3V0KGUsMCl9aWYoKHI9PT1kZWZhdWx0U2V0VGltb3V0fHwhcikmJnNldFRpbWVvdXQpe3I9c2V0VGltZW91dDtyZXR1cm4gc2V0VGltZW91dChlLDApfXRyeXtyZXR1cm4gcihlLDApfWNhdGNoKHQpe3RyeXtyZXR1cm4gci5jYWxsKG51bGwsZSwwKX1jYXRjaCh0KXtyZXR1cm4gci5jYWxsKHRoaXMsZSwwKX19fWZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChlKXtpZihuPT09Y2xlYXJUaW1lb3V0KXtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfWlmKChuPT09ZGVmYXVsdENsZWFyVGltZW91dHx8IW4pJiZjbGVhclRpbWVvdXQpe249Y2xlYXJUaW1lb3V0O3JldHVybiBjbGVhclRpbWVvdXQoZSl9dHJ5e3JldHVybiBuKGUpfWNhdGNoKHQpe3RyeXtyZXR1cm4gbi5jYWxsKG51bGwsZSl9Y2F0Y2godCl7cmV0dXJuIG4uY2FsbCh0aGlzLGUpfX19dmFyIGk9W107dmFyIG89ZmFsc2U7dmFyIHU7dmFyIGE9LTE7ZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCl7aWYoIW98fCF1KXtyZXR1cm59bz1mYWxzZTtpZih1Lmxlbmd0aCl7aT11LmNvbmNhdChpKX1lbHNle2E9LTF9aWYoaS5sZW5ndGgpe2RyYWluUXVldWUoKX19ZnVuY3Rpb24gZHJhaW5RdWV1ZSgpe2lmKG8pe3JldHVybn12YXIgZT1ydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7bz10cnVlO3ZhciB0PWkubGVuZ3RoO3doaWxlKHQpe3U9aTtpPVtdO3doaWxlKCsrYTx0KXtpZih1KXt1W2FdLnJ1bigpfX1hPS0xO3Q9aS5sZW5ndGh9dT1udWxsO289ZmFsc2U7cnVuQ2xlYXJUaW1lb3V0KGUpfXQubmV4dFRpY2s9ZnVuY3Rpb24oZSl7dmFyIHQ9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoYXJndW1lbnRzLmxlbmd0aD4xKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt0W3ItMV09YXJndW1lbnRzW3JdfX1pLnB1c2gobmV3IEl0ZW0oZSx0KSk7aWYoaS5sZW5ndGg9PT0xJiYhbyl7cnVuVGltZW91dChkcmFpblF1ZXVlKX19O2Z1bmN0aW9uIEl0ZW0oZSx0KXt0aGlzLmZ1bj1lO3RoaXMuYXJyYXk9dH1JdGVtLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfTt0LnRpdGxlPVwiYnJvd3NlclwiO3QuYnJvd3Nlcj10cnVlO3QuZW52PXt9O3QuYXJndj1bXTt0LnZlcnNpb249XCJcIjt0LnZlcnNpb25zPXt9O2Z1bmN0aW9uIG5vb3AoKXt9dC5vbj1ub29wO3QuYWRkTGlzdGVuZXI9bm9vcDt0Lm9uY2U9bm9vcDt0Lm9mZj1ub29wO3QucmVtb3ZlTGlzdGVuZXI9bm9vcDt0LnJlbW92ZUFsbExpc3RlbmVycz1ub29wO3QuZW1pdD1ub29wO3QucHJlcGVuZExpc3RlbmVyPW5vb3A7dC5wcmVwZW5kT25jZUxpc3RlbmVyPW5vb3A7dC5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuW119O3QuYmluZGluZz1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX07dC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn07dC5jaGRpcj1mdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QudW1hc2s9ZnVuY3Rpb24oKXtyZXR1cm4gMH19fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT10W3JdPXtleHBvcnRzOnt9fTt2YXIgbz10cnVlO3RyeXtlW3JdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO289ZmFsc2V9ZmluYWxseXtpZihvKWRlbGV0ZSB0W3JdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oMjI5KTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/hbc/HbcAgTable.tsx":
/*!***************************************!*\
  !*** ./components/hbc/HbcAgTable.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HbcAgTable: function() { return /* binding */ HbcAgTable; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! styled-jsx/style */ \"(app-pages-browser)/./node_modules/styled-jsx/style.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ag_grid_community_styles_ag_grid_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ag-grid-community/styles/ag-grid.css */ \"(app-pages-browser)/./node_modules/ag-grid-community/styles/ag-grid.css\");\n/* harmony import */ var ag_grid_community_styles_ag_theme_quartz_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ag-grid-community/styles/ag-theme-quartz.css */ \"(app-pages-browser)/./node_modules/ag-grid-community/styles/ag-theme-quartz.css\");\n/* harmony import */ var ag_grid_community__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ag-grid-community */ \"(app-pages-browser)/./node_modules/ag-grid-community/dist/package/main.esm.mjs\");\n/* harmony import */ var ag_grid_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ag-grid-react */ \"(app-pages-browser)/./node_modules/ag-grid-react/dist/package/index.esm.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);\n// HbcAgTable.tsx\n/* __next_internal_client_entry_do_not_use__ HbcAgTable auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\nlet agGridRegistered = false;\nif (!agGridRegistered) {\n    ag_grid_community__WEBPACK_IMPORTED_MODULE_6__.ModuleRegistry.registerModules([\n        ag_grid_community__WEBPACK_IMPORTED_MODULE_6__.AllCommunityModule\n    ]);\n    agGridRegistered = true;\n}\nfunction HbcAgTable(param) {\n    let { rowData, columnDefs, className, height = \"100%\", loading, error, gridOptions, rowIdField, onGridReady, onFilterChanged, onSortChanged, onSelectionChanged, onCellClicked, onCellDoubleClicked, onCellKeyDown, onFilterPaste } = param;\n    _s();\n    const gridApiRef = (0,react__WEBPACK_IMPORTED_MODULE_5__.useRef)(null);\n    const columnFilterTypeByColId = (0,react__WEBPACK_IMPORTED_MODULE_5__.useMemo)(()=>{\n        const map = new Map();\n        for (const def of columnDefs !== null && columnDefs !== void 0 ? columnDefs : []){\n            var _def_colId;\n            const colId = (_def_colId = def.colId) !== null && _def_colId !== void 0 ? _def_colId : def.field;\n            if (!colId) continue;\n            map.set(colId, def.filter);\n        }\n        return map;\n    }, [\n        columnDefs\n    ]);\n    async function copyText(text) {\n        try {\n            var _navigator_clipboard, _navigator;\n            if ((_navigator = navigator) === null || _navigator === void 0 ? void 0 : (_navigator_clipboard = _navigator.clipboard) === null || _navigator_clipboard === void 0 ? void 0 : _navigator_clipboard.writeText) {\n                await navigator.clipboard.writeText(text);\n                return;\n            }\n        } catch (e) {\n        // ignore and fall back\n        }\n        const el = document.createElement(\"textarea\");\n        el.value = text;\n        el.setAttribute(\"readonly\", \"true\");\n        el.style.position = \"fixed\";\n        el.style.top = \"-9999px\";\n        document.body.appendChild(el);\n        el.select();\n        document.execCommand(\"copy\");\n        document.body.removeChild(el);\n    }\n    function handleCellKeyDown(e) {\n        var _ev_key;\n        onCellKeyDown === null || onCellKeyDown === void 0 ? void 0 : onCellKeyDown(e);\n        const ev = e.event;\n        if (!ev) return;\n        const key = (_ev_key = ev.key) === null || _ev_key === void 0 ? void 0 : _ev_key.toLowerCase();\n        const isCopy = (ev.metaKey || ev.ctrlKey) && key === \"c\" && !ev.shiftKey && !ev.altKey;\n        if (!isCopy) return;\n        const value = e.value;\n        if (value === null || value === undefined) return;\n        const text = typeof value === \"string\" ? value : String(value);\n        ev.preventDefault();\n        void copyText(text);\n    }\n    function findFloatingFilterColumnId(target) {\n        var _target_closest;\n        if (!target || !(target instanceof HTMLElement)) return null;\n        const direct = (_target_closest = target.closest(\"[col-id]\")) === null || _target_closest === void 0 ? void 0 : _target_closest.getAttribute(\"col-id\");\n        if (direct && direct.length) return direct;\n        const floating = target.closest(\".ag-floating-filter\");\n        if (!floating) return null;\n        const headerCell = target.closest(\".ag-header-cell\");\n        const colId = headerCell === null || headerCell === void 0 ? void 0 : headerCell.getAttribute(\"col-id\");\n        return colId && colId.length ? colId : null;\n    }\n    function setEqualsForTextFilter(colId, filterText) {\n        var _api_onFilterChanged;\n        const api = gridApiRef.current;\n        if (!api) return;\n        var _api_getFilterModel;\n        const model = (_api_getFilterModel = api.getFilterModel()) !== null && _api_getFilterModel !== void 0 ? _api_getFilterModel : {};\n        const existing = model[colId];\n        const nextText = typeof filterText === \"string\" ? filterText : existing === null || existing === void 0 ? void 0 : existing.filter;\n        if (typeof nextText !== \"string\") return;\n        const trimmed = nextText.trim();\n        if (!trimmed) return;\n        const existingType = (existing === null || existing === void 0 ? void 0 : existing.type) ? String(existing.type).toLowerCase() : \"\";\n        const existingValue = typeof (existing === null || existing === void 0 ? void 0 : existing.filter) === \"string\" ? existing.filter.trim() : \"\";\n        if (existingType === \"equals\" && existingValue === trimmed) return;\n        var _existing_filterType;\n        api.setFilterModel({\n            ...model,\n            [colId]: {\n                ...existing !== null && existing !== void 0 ? existing : {},\n                filterType: (_existing_filterType = existing === null || existing === void 0 ? void 0 : existing.filterType) !== null && _existing_filterType !== void 0 ? _existing_filterType : \"text\",\n                type: \"equals\",\n                filter: trimmed\n            }\n        });\n        (_api_onFilterChanged = api.onFilterChanged) === null || _api_onFilterChanged === void 0 ? void 0 : _api_onFilterChanged.call(api);\n    }\n    function parseDateFromText(input) {\n        const text = input.trim();\n        if (!text) return null;\n        const isoMatch = /^(\\d{4}-\\d{2}-\\d{2})/.exec(text);\n        if (isoMatch) return isoMatch[1];\n        const ms = Date.parse(text);\n        if (!Number.isFinite(ms)) return null;\n        const d = new Date(ms);\n        const yyyy = String(d.getFullYear()).padStart(4, \"0\");\n        const mm = String(d.getMonth() + 1).padStart(2, \"0\");\n        const dd = String(d.getDate()).padStart(2, \"0\");\n        return \"\".concat(yyyy, \"-\").concat(mm, \"-\").concat(dd);\n    }\n    function setEqualsForDateFilter(colId, filterText) {\n        var _api_onFilterChanged;\n        const api = gridApiRef.current;\n        if (!api) return;\n        var _api_getFilterModel;\n        const model = (_api_getFilterModel = api.getFilterModel()) !== null && _api_getFilterModel !== void 0 ? _api_getFilterModel : {};\n        const existing = model[colId];\n        const nextText = typeof filterText === \"string\" ? filterText : existing === null || existing === void 0 ? void 0 : existing.dateFrom;\n        if (typeof nextText !== \"string\") return;\n        const dateFrom = parseDateFromText(nextText);\n        if (!dateFrom) return;\n        const existingType = (existing === null || existing === void 0 ? void 0 : existing.type) ? String(existing.type).toLowerCase() : \"\";\n        const existingDateFrom = typeof (existing === null || existing === void 0 ? void 0 : existing.dateFrom) === \"string\" ? existing.dateFrom.trim() : \"\";\n        if (existingType === \"equals\" && existingDateFrom === dateFrom) return;\n        api.setFilterModel({\n            ...model,\n            [colId]: {\n                ...existing !== null && existing !== void 0 ? existing : {},\n                filterType: \"date\",\n                type: \"equals\",\n                dateFrom\n            }\n        });\n        (_api_onFilterChanged = api.onFilterChanged) === null || _api_onFilterChanged === void 0 ? void 0 : _api_onFilterChanged.call(api);\n    }\n    function getPreferredFilterType(colId) {\n        const api = gridApiRef.current;\n        var _api_getFilterModel;\n        const model = (_api_getFilterModel = api === null || api === void 0 ? void 0 : api.getFilterModel()) !== null && _api_getFilterModel !== void 0 ? _api_getFilterModel : {};\n        const existing = model[colId];\n        const existingFilterType = typeof (existing === null || existing === void 0 ? void 0 : existing.filterType) === \"string\" ? existing.filterType : undefined;\n        if (existingFilterType) return existingFilterType;\n        const colFilter = columnFilterTypeByColId.get(colId);\n        if (colFilter === \"agDateColumnFilter\") return \"date\";\n        if (colFilter === \"agNumberColumnFilter\") return \"number\";\n        return \"text\";\n    }\n    function handleKeyDownCapture(ev) {\n        var _ev_key;\n        const key = (_ev_key = ev.key) === null || _ev_key === void 0 ? void 0 : _ev_key.toLowerCase();\n        const isCopy = (ev.metaKey || ev.ctrlKey) && key === \"c\" && !ev.shiftKey && !ev.altKey;\n        const isPaste = (ev.metaKey || ev.ctrlKey) && key === \"v\" && !ev.shiftKey && !ev.altKey;\n        if (!isCopy && !isPaste) return;\n        const colId = findFloatingFilterColumnId(ev.target);\n        if (!colId) {\n            if (isCopy) {\n                const text = getFocusedCellText();\n                if (!text) return;\n                ev.preventDefault();\n                void copyText(text);\n            }\n            return;\n        }\n        if (isPaste) {\n            onFilterPaste === null || onFilterPaste === void 0 ? void 0 : onFilterPaste(colId);\n            window.setTimeout(()=>{\n                const el = ev.target;\n                const value = el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement ? el.value : undefined;\n                const filterType = getPreferredFilterType(colId);\n                if (filterType === \"date\") {\n                    setEqualsForDateFilter(colId, value);\n                    return;\n                }\n                setEqualsForTextFilter(colId, value);\n            }, 40);\n            return;\n        }\n        if (isCopy) {\n            const text = getFocusedCellText();\n            if (!text) return;\n            ev.preventDefault();\n            void copyText(text);\n        }\n    }\n    function handlePasteCapture(ev) {\n        const colId = findFloatingFilterColumnId(ev.target);\n        if (!colId) return;\n        onFilterPaste === null || onFilterPaste === void 0 ? void 0 : onFilterPaste(colId);\n        window.setTimeout(()=>{\n            const el = ev.target;\n            const value = el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement ? el.value : undefined;\n            const filterType = getPreferredFilterType(colId);\n            if (filterType === \"date\") {\n                setEqualsForDateFilter(colId, value);\n                return;\n            }\n            setEqualsForTextFilter(colId, value);\n        }, 40);\n    }\n    function getFocusedCellText() {\n        var _api_getFocusedCell, _api_getDisplayedRowAtIndex, _focused_column_getColId, _focused_column, _rowNode_data;\n        const api = gridApiRef.current;\n        if (!api) return null;\n        const focused = (_api_getFocusedCell = api.getFocusedCell) === null || _api_getFocusedCell === void 0 ? void 0 : _api_getFocusedCell.call(api);\n        if (!focused) return null;\n        const rowNode = (_api_getDisplayedRowAtIndex = api.getDisplayedRowAtIndex) === null || _api_getDisplayedRowAtIndex === void 0 ? void 0 : _api_getDisplayedRowAtIndex.call(api, focused.rowIndex);\n        const colId = (_focused_column = focused.column) === null || _focused_column === void 0 ? void 0 : (_focused_column_getColId = _focused_column.getColId) === null || _focused_column_getColId === void 0 ? void 0 : _focused_column_getColId.call(_focused_column);\n        if (!rowNode || !colId) return null;\n        const value = (_rowNode_data = rowNode.data) === null || _rowNode_data === void 0 ? void 0 : _rowNode_data[colId];\n        if (value === null || value === undefined) return null;\n        return typeof value === \"string\" ? value : String(value);\n    }\n    const autoColumnDefs = (0,react__WEBPACK_IMPORTED_MODULE_5__.useMemo)(()=>{\n        if (columnDefs && columnDefs.length) return columnDefs;\n        var _rowData_;\n        const keys = Object.keys((_rowData_ = rowData === null || rowData === void 0 ? void 0 : rowData[0]) !== null && _rowData_ !== void 0 ? _rowData_ : {});\n        return keys.map((field)=>({\n                field\n            }));\n    }, [\n        columnDefs,\n        rowData\n    ]);\n    const defaultColDef = (0,react__WEBPACK_IMPORTED_MODULE_5__.useMemo)(()=>({\n            resizable: true,\n            suppressMovable: false,\n            sortable: true,\n            unSortIcon: true,\n            filter: true,\n            floatingFilter: true,\n            minWidth: 90\n        }), []);\n    const mergedGridOptions = (0,react__WEBPACK_IMPORTED_MODULE_5__.useMemo)(()=>({\n            theme: \"legacy\",\n            animateRows: true,\n            rowSelection: \"single\",\n            suppressCellFocus: false,\n            pagination: false,\n            suppressMovableColumns: false,\n            alwaysShowHorizontalScroll: true,\n            suppressHorizontalScroll: false,\n            suppressRowClickSelection: true,\n            enableCellTextSelection: true,\n            ensureDomOrder: true,\n            ...gridOptions !== null && gridOptions !== void 0 ? gridOptions : {}\n        }), [\n        gridOptions\n    ]);\n    const finalClassName = [\n        \"hbc-ag-grid ag-theme-quartz-dark w-full rounded-lg border border-[color:var(--color-border)] bg-[color:var(--color-card)]\",\n        className\n    ].filter(Boolean).join(\" \");\n    const gridContainerStyle = (0,react__WEBPACK_IMPORTED_MODULE_5__.useMemo)(()=>{\n        return {\n            height: \"100%\",\n            \"--ag-border-color\": \"rgba(255, 255, 255, 0.16)\",\n            \"--ag-secondary-border-color\": \"rgba(255, 255, 255, 0.12)\",\n            \"--ag-header-column-resize-handle-color\": \"rgba(255, 255, 255, 0.65)\",\n            \"--ag-header-column-resize-handle-width\": \"4px\",\n            \"--ag-header-column-resize-handle-height\": \"60%\"\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-full\",\n        style: {\n            height\n        },\n        onKeyDownCapture: handleKeyDownCapture,\n        onPasteCapture: handlePasteCapture,\n        children: [\n            error ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mb-3 rounded-md border border-red-500/40 bg-red-500/10 px-3 py-2 text-sm text-red-200\",\n                children: error\n            }, void 0, false, {\n                fileName: \"/Users/alexandershubert/git/hbc_tsy_enhanced/hbc_web/components/hbc/HbcAgTable.tsx\",\n                lineNumber: 350,\n                columnNumber: 9\n            }, this) : null,\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: gridContainerStyle,\n                className: \"jsx-22d5c091a0aa6afd\" + \" \" + (finalClassName || \"\"),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default()), {\n                        id: \"22d5c091a0aa6afd\",\n                        children: \".hbc-ag-grid .ag-header-cell-resize{cursor:col-resize}.hbc-ag-grid .ag-header-cell-resize::after{cursor:col-resize}\"\n                    }, void 0, false, void 0, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ag_grid_react__WEBPACK_IMPORTED_MODULE_4__.AgGridReact, {\n                        rowData: rowData,\n                        columnDefs: autoColumnDefs,\n                        defaultColDef: defaultColDef,\n                        gridOptions: mergedGridOptions,\n                        loading: loading,\n                        onGridReady: (e)=>{\n                            gridApiRef.current = e.api;\n                            onGridReady === null || onGridReady === void 0 ? void 0 : onGridReady(e);\n                        },\n                        onFilterChanged: onFilterChanged,\n                        onSortChanged: onSortChanged,\n                        onSelectionChanged: onSelectionChanged,\n                        onCellClicked: onCellClicked,\n                        onCellDoubleClicked: onCellDoubleClicked,\n                        onCellKeyDown: handleCellKeyDown,\n                        getRowId: rowIdField ? (p)=>{\n                            var _p_data;\n                            const raw = (_p_data = p.data) === null || _p_data === void 0 ? void 0 : _p_data[rowIdField];\n                            if (typeof raw === \"string\" && raw.length) return raw;\n                            if (typeof raw === \"number\") return String(raw);\n                            return JSON.stringify(p.data);\n                        } : undefined\n                    }, void 0, false, {\n                        fileName: \"/Users/alexandershubert/git/hbc_tsy_enhanced/hbc_web/components/hbc/HbcAgTable.tsx\",\n                        lineNumber: 364,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/alexandershubert/git/hbc_tsy_enhanced/hbc_web/components/hbc/HbcAgTable.tsx\",\n                lineNumber: 355,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/alexandershubert/git/hbc_tsy_enhanced/hbc_web/components/hbc/HbcAgTable.tsx\",\n        lineNumber: 343,\n        columnNumber: 5\n    }, this);\n}\n_s(HbcAgTable, \"aimUXJcSLUshu1bfyPjbYl8we94=\");\n_c = HbcAgTable;\nvar _c;\n$RefreshReg$(_c, \"HbcAgTable\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvaGJjL0hiY0FnVGFibGUudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxpQkFBaUI7Ozs7QUFHNEI7QUFDUTtBQUVpQjtBQU0zQjtBQUdKO0FBRXZDLElBQUlLLG1CQUFtQjtBQUN2QixJQUFJLENBQUNBLGtCQUFrQjtJQUNyQkosNkRBQWNBLENBQUNLLGVBQWUsQ0FBQztRQUFDTixpRUFBa0JBO0tBQUM7SUFDbkRLLG1CQUFtQjtBQUNyQjtBQXFCTyxTQUFTRSxXQUE4QyxLQWlCekM7UUFqQnlDLEVBQzVEQyxPQUFPLEVBQ1BDLFVBQVUsRUFDVkMsU0FBUyxFQUNUQyxTQUFTLE1BQU0sRUFDZkMsT0FBTyxFQUNQQyxLQUFLLEVBQ0xDLFdBQVcsRUFDWEMsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLGVBQWUsRUFDZkMsYUFBYSxFQUNiQyxrQkFBa0IsRUFDbEJDLGFBQWEsRUFDYkMsbUJBQW1CLEVBQ25CQyxhQUFhLEVBQ2JDLGFBQWEsRUFDTSxHQWpCeUM7O0lBa0I1RCxNQUFNQyxhQUFhcEIsNkNBQU1BLENBQW9CO0lBQzdDLE1BQU1xQiwwQkFBMEJ0Qiw4Q0FBT0EsQ0FBQztRQUN0QyxNQUFNdUIsTUFBTSxJQUFJQztRQUNoQixLQUFLLE1BQU1DLE9BQU9uQix1QkFBQUEsd0JBQUFBLGFBQWMsRUFBRSxDQUFFO2dCQUNuQm1CO1lBQWYsTUFBTUMsUUFBU0QsQ0FBQUEsYUFBQUEsSUFBSUMsS0FBSyxjQUFURCx3QkFBQUEsYUFBYUEsSUFBSUUsS0FBSztZQUNyQyxJQUFJLENBQUNELE9BQU87WUFDWkgsSUFBSUssR0FBRyxDQUFDRixPQUFPRCxJQUFJSSxNQUFNO1FBQzNCO1FBQ0EsT0FBT047SUFDVCxHQUFHO1FBQUNqQjtLQUFXO0lBRWYsZUFBZXdCLFNBQVNDLElBQVk7UUFDbEMsSUFBSTtnQkFDRUMsc0JBQUFBO1lBQUosS0FBSUEsYUFBQUEsdUJBQUFBLGtDQUFBQSx1QkFBQUEsV0FBV0MsU0FBUyxjQUFwQkQsMkNBQUFBLHFCQUFzQkUsU0FBUyxFQUFFO2dCQUNuQyxNQUFNRixVQUFVQyxTQUFTLENBQUNDLFNBQVMsQ0FBQ0g7Z0JBQ3BDO1lBQ0Y7UUFDRixFQUFFLFVBQU07UUFDTix1QkFBdUI7UUFDekI7UUFFQSxNQUFNSSxLQUFLQyxTQUFTQyxhQUFhLENBQUM7UUFDbENGLEdBQUdHLEtBQUssR0FBR1A7UUFDWEksR0FBR0ksWUFBWSxDQUFDLFlBQVk7UUFDNUJKLEdBQUdLLEtBQUssQ0FBQ0MsUUFBUSxHQUFHO1FBQ3BCTixHQUFHSyxLQUFLLENBQUNFLEdBQUcsR0FBRztRQUNmTixTQUFTTyxJQUFJLENBQUNDLFdBQVcsQ0FBQ1Q7UUFDMUJBLEdBQUdVLE1BQU07UUFDVFQsU0FBU1UsV0FBVyxDQUFDO1FBQ3JCVixTQUFTTyxJQUFJLENBQUNJLFdBQVcsQ0FBQ1o7SUFDNUI7SUFFQSxTQUFTYSxrQkFBa0JDLENBQXNCO1lBTW5DQztRQUxaL0IsMEJBQUFBLG9DQUFBQSxjQUFnQjhCO1FBRWhCLE1BQU1DLEtBQUtELEVBQUVFLEtBQUs7UUFDbEIsSUFBSSxDQUFDRCxJQUFJO1FBRVQsTUFBTUUsT0FBTUYsVUFBQUEsR0FBR0UsR0FBRyxjQUFORiw4QkFBQUEsUUFBUUcsV0FBVztRQUMvQixNQUFNQyxTQUFTLENBQUNKLEdBQUdLLE9BQU8sSUFBSUwsR0FBR00sT0FBTyxLQUFLSixRQUFRLE9BQU8sQ0FBQ0YsR0FBR08sUUFBUSxJQUFJLENBQUNQLEdBQUdRLE1BQU07UUFDdEYsSUFBSSxDQUFDSixRQUFRO1FBRWIsTUFBTWhCLFFBQVFXLEVBQUVYLEtBQUs7UUFDckIsSUFBSUEsVUFBVSxRQUFRQSxVQUFVcUIsV0FBVztRQUMzQyxNQUFNNUIsT0FBTyxPQUFPTyxVQUFVLFdBQVdBLFFBQVFzQixPQUFPdEI7UUFFeERZLEdBQUdXLGNBQWM7UUFDakIsS0FBSy9CLFNBQVNDO0lBQ2hCO0lBRUEsU0FBUytCLDJCQUEyQkMsTUFBMEI7WUFFN0NBO1FBRGYsSUFBSSxDQUFDQSxVQUFVLENBQUVBLENBQUFBLGtCQUFrQkMsV0FBVSxHQUFJLE9BQU87UUFDeEQsTUFBTUMsVUFBU0Ysa0JBQUFBLE9BQU9HLE9BQU8sQ0FBQyx5QkFBZkgsc0NBQUFBLGdCQUE0QkksWUFBWSxDQUFDO1FBQ3hELElBQUlGLFVBQVVBLE9BQU9HLE1BQU0sRUFBRSxPQUFPSDtRQUVwQyxNQUFNSSxXQUFXTixPQUFPRyxPQUFPLENBQUM7UUFDaEMsSUFBSSxDQUFDRyxVQUFVLE9BQU87UUFFdEIsTUFBTUMsYUFBYVAsT0FBT0csT0FBTyxDQUFDO1FBQ2xDLE1BQU14QyxRQUFRNEMsdUJBQUFBLGlDQUFBQSxXQUFZSCxZQUFZLENBQUM7UUFDdkMsT0FBT3pDLFNBQVNBLE1BQU0wQyxNQUFNLEdBQUcxQyxRQUFRO0lBQ3pDO0lBRUEsU0FBUzZDLHVCQUF1QjdDLEtBQWEsRUFBRThDLFVBQW1CO1lBd0JoRUM7UUF2QkEsTUFBTUEsTUFBTXBELFdBQVdxRCxPQUFPO1FBQzlCLElBQUksQ0FBQ0QsS0FBSztZQUVLQTtRQUFmLE1BQU1FLFFBQVEsQ0FBQ0Ysc0JBQUFBLElBQUlHLGNBQWMsZ0JBQWxCSCxpQ0FBQUEsc0JBQWdELENBQUM7UUFDaEUsTUFBTUksV0FBV0YsS0FBSyxDQUFDakQsTUFBTTtRQUM3QixNQUFNb0QsV0FBVyxPQUFPTixlQUFlLFdBQVdBLGFBQWFLLHFCQUFBQSwrQkFBQUEsU0FBVWhELE1BQU07UUFDL0UsSUFBSSxPQUFPaUQsYUFBYSxVQUFVO1FBQ2xDLE1BQU1DLFVBQVVELFNBQVNFLElBQUk7UUFDN0IsSUFBSSxDQUFDRCxTQUFTO1FBRWQsTUFBTUUsZUFBZUosQ0FBQUEscUJBQUFBLCtCQUFBQSxTQUFVSyxJQUFJLElBQUd0QixPQUFPaUIsU0FBU0ssSUFBSSxFQUFFN0IsV0FBVyxLQUFLO1FBQzVFLE1BQU04QixnQkFBZ0IsUUFBT04scUJBQUFBLCtCQUFBQSxTQUFVaEQsTUFBTSxNQUFLLFdBQVdnRCxTQUFTaEQsTUFBTSxDQUFDbUQsSUFBSSxLQUFLO1FBQ3RGLElBQUlDLGlCQUFpQixZQUFZRSxrQkFBa0JKLFNBQVM7WUFNM0NGO1FBSmpCSixJQUFJVyxjQUFjLENBQUM7WUFDakIsR0FBR1QsS0FBSztZQUNSLENBQUNqRCxNQUFNLEVBQUU7Z0JBQ1AsR0FBSW1ELHFCQUFBQSxzQkFBQUEsV0FBWSxDQUFDLENBQUM7Z0JBQ2xCUSxZQUFZLENBQUNSLHVCQUFBQSxxQkFBQUEsK0JBQUFBLFNBQVVRLFVBQVUsY0FBcEJSLGtDQUFBQSx1QkFBK0M7Z0JBQzVESyxNQUFNO2dCQUNOckQsUUFBUWtEO1lBQ1Y7UUFDRjtTQUNBTix1QkFBQUEsSUFBSTNELGVBQWUsY0FBbkIyRCwyQ0FBQUEsMEJBQUFBO0lBQ0Y7SUFFQSxTQUFTYSxrQkFBa0JDLEtBQWE7UUFDdEMsTUFBTXhELE9BQU93RCxNQUFNUCxJQUFJO1FBQ3ZCLElBQUksQ0FBQ2pELE1BQU0sT0FBTztRQUVsQixNQUFNeUQsV0FBVyx1QkFBdUJDLElBQUksQ0FBQzFEO1FBQzdDLElBQUl5RCxVQUFVLE9BQU9BLFFBQVEsQ0FBQyxFQUFFO1FBRWhDLE1BQU1FLEtBQUtDLEtBQUtDLEtBQUssQ0FBQzdEO1FBQ3RCLElBQUksQ0FBQzhELE9BQU9DLFFBQVEsQ0FBQ0osS0FBSyxPQUFPO1FBRWpDLE1BQU1LLElBQUksSUFBSUosS0FBS0Q7UUFDbkIsTUFBTU0sT0FBT3BDLE9BQU9tQyxFQUFFRSxXQUFXLElBQUlDLFFBQVEsQ0FBQyxHQUFHO1FBQ2pELE1BQU1DLEtBQUt2QyxPQUFPbUMsRUFBRUssUUFBUSxLQUFLLEdBQUdGLFFBQVEsQ0FBQyxHQUFHO1FBQ2hELE1BQU1HLEtBQUt6QyxPQUFPbUMsRUFBRU8sT0FBTyxJQUFJSixRQUFRLENBQUMsR0FBRztRQUMzQyxPQUFPLEdBQVdDLE9BQVJILE1BQUssS0FBU0ssT0FBTkYsSUFBRyxLQUFNLE9BQUhFO0lBQzFCO0lBRUEsU0FBU0UsdUJBQXVCN0UsS0FBYSxFQUFFOEMsVUFBbUI7WUEwQmhFQztRQXpCQSxNQUFNQSxNQUFNcEQsV0FBV3FELE9BQU87UUFDOUIsSUFBSSxDQUFDRCxLQUFLO1lBRUtBO1FBQWYsTUFBTUUsUUFBUSxDQUFDRixzQkFBQUEsSUFBSUcsY0FBYyxnQkFBbEJILGlDQUFBQSxzQkFBZ0QsQ0FBQztRQUNoRSxNQUFNSSxXQUFXRixLQUFLLENBQUNqRCxNQUFNO1FBRTdCLE1BQU1vRCxXQUFXLE9BQU9OLGVBQWUsV0FBV0EsYUFBYUsscUJBQUFBLCtCQUFBQSxTQUFVMkIsUUFBUTtRQUNqRixJQUFJLE9BQU8xQixhQUFhLFVBQVU7UUFFbEMsTUFBTTBCLFdBQVdsQixrQkFBa0JSO1FBQ25DLElBQUksQ0FBQzBCLFVBQVU7UUFFZixNQUFNdkIsZUFBZUosQ0FBQUEscUJBQUFBLCtCQUFBQSxTQUFVSyxJQUFJLElBQUd0QixPQUFPaUIsU0FBU0ssSUFBSSxFQUFFN0IsV0FBVyxLQUFLO1FBQzVFLE1BQU1vRCxtQkFBbUIsUUFBTzVCLHFCQUFBQSwrQkFBQUEsU0FBVTJCLFFBQVEsTUFBSyxXQUFXM0IsU0FBUzJCLFFBQVEsQ0FBQ3hCLElBQUksS0FBSztRQUM3RixJQUFJQyxpQkFBaUIsWUFBWXdCLHFCQUFxQkQsVUFBVTtRQUVoRS9CLElBQUlXLGNBQWMsQ0FBQztZQUNqQixHQUFHVCxLQUFLO1lBQ1IsQ0FBQ2pELE1BQU0sRUFBRTtnQkFDUCxHQUFJbUQscUJBQUFBLHNCQUFBQSxXQUFZLENBQUMsQ0FBQztnQkFDbEJRLFlBQVk7Z0JBQ1pILE1BQU07Z0JBQ05zQjtZQUNGO1FBQ0Y7U0FDQS9CLHVCQUFBQSxJQUFJM0QsZUFBZSxjQUFuQjJELDJDQUFBQSwwQkFBQUE7SUFDRjtJQUVBLFNBQVNpQyx1QkFBdUJoRixLQUFhO1FBQzNDLE1BQU0rQyxNQUFNcEQsV0FBV3FELE9BQU87WUFDZkQ7UUFBZixNQUFNRSxRQUFRLENBQUNGLHNCQUFBQSxnQkFBQUEsMEJBQUFBLElBQUtHLGNBQWMsZ0JBQW5CSCxpQ0FBQUEsc0JBQWlELENBQUM7UUFDakUsTUFBTUksV0FBV0YsS0FBSyxDQUFDakQsTUFBTTtRQUM3QixNQUFNaUYscUJBQXFCLFFBQU85QixxQkFBQUEsK0JBQUFBLFNBQVVRLFVBQVUsTUFBSyxXQUFXUixTQUFTUSxVQUFVLEdBQUcxQjtRQUM1RixJQUFJZ0Qsb0JBQW9CLE9BQU9BO1FBRS9CLE1BQU1DLFlBQVl0Rix3QkFBd0J1RixHQUFHLENBQUNuRjtRQUM5QyxJQUFJa0YsY0FBYyxzQkFBc0IsT0FBTztRQUMvQyxJQUFJQSxjQUFjLHdCQUF3QixPQUFPO1FBQ2pELE9BQU87SUFDVDtJQUVBLFNBQVNFLHFCQUFxQjVELEVBQXNCO1lBQ3RDQTtRQUFaLE1BQU1FLE9BQU1GLFVBQUFBLEdBQUdFLEdBQUcsY0FBTkYsOEJBQUFBLFFBQVFHLFdBQVc7UUFDL0IsTUFBTUMsU0FBUyxDQUFDSixHQUFHSyxPQUFPLElBQUlMLEdBQUdNLE9BQU8sS0FBS0osUUFBUSxPQUFPLENBQUNGLEdBQUdPLFFBQVEsSUFBSSxDQUFDUCxHQUFHUSxNQUFNO1FBQ3RGLE1BQU1xRCxVQUFVLENBQUM3RCxHQUFHSyxPQUFPLElBQUlMLEdBQUdNLE9BQU8sS0FBS0osUUFBUSxPQUFPLENBQUNGLEdBQUdPLFFBQVEsSUFBSSxDQUFDUCxHQUFHUSxNQUFNO1FBRXZGLElBQUksQ0FBQ0osVUFBVSxDQUFDeUQsU0FBUztRQUV6QixNQUFNckYsUUFBUW9DLDJCQUEyQlosR0FBR2EsTUFBTTtRQUNsRCxJQUFJLENBQUNyQyxPQUFPO1lBQ1YsSUFBSTRCLFFBQVE7Z0JBQ1YsTUFBTXZCLE9BQU9pRjtnQkFDYixJQUFJLENBQUNqRixNQUFNO2dCQUNYbUIsR0FBR1csY0FBYztnQkFDakIsS0FBSy9CLFNBQVNDO1lBQ2hCO1lBQ0E7UUFDRjtRQUVBLElBQUlnRixTQUFTO1lBQ1gzRiwwQkFBQUEsb0NBQUFBLGNBQWdCTTtZQUNoQnVGLE9BQU9DLFVBQVUsQ0FBQztnQkFDaEIsTUFBTS9FLEtBQUtlLEdBQUdhLE1BQU07Z0JBQ3BCLE1BQU16QixRQUNKSCxjQUFjZ0Ysb0JBQW9CaEYsY0FBY2lGLHNCQUFzQmpGLEdBQUdHLEtBQUssR0FBR3FCO2dCQUNuRixNQUFNMEIsYUFBYXFCLHVCQUF1QmhGO2dCQUMxQyxJQUFJMkQsZUFBZSxRQUFRO29CQUN6QmtCLHVCQUF1QjdFLE9BQU9ZO29CQUM5QjtnQkFDRjtnQkFDQWlDLHVCQUF1QjdDLE9BQU9ZO1lBQ2hDLEdBQUc7WUFDSDtRQUNGO1FBRUEsSUFBSWdCLFFBQVE7WUFDVixNQUFNdkIsT0FBT2lGO1lBQ2IsSUFBSSxDQUFDakYsTUFBTTtZQUNYbUIsR0FBR1csY0FBYztZQUNqQixLQUFLL0IsU0FBU0M7UUFDaEI7SUFDRjtJQUVBLFNBQVNzRixtQkFBbUJuRSxFQUF3QjtRQUNsRCxNQUFNeEIsUUFBUW9DLDJCQUEyQlosR0FBR2EsTUFBTTtRQUNsRCxJQUFJLENBQUNyQyxPQUFPO1FBRVpOLDBCQUFBQSxvQ0FBQUEsY0FBZ0JNO1FBQ2hCdUYsT0FBT0MsVUFBVSxDQUFDO1lBQ2hCLE1BQU0vRSxLQUFLZSxHQUFHYSxNQUFNO1lBQ3BCLE1BQU16QixRQUFRSCxjQUFjZ0Ysb0JBQW9CaEYsY0FBY2lGLHNCQUFzQmpGLEdBQUdHLEtBQUssR0FBR3FCO1lBQy9GLE1BQU0wQixhQUFhcUIsdUJBQXVCaEY7WUFDMUMsSUFBSTJELGVBQWUsUUFBUTtnQkFDekJrQix1QkFBdUI3RSxPQUFPWTtnQkFDOUI7WUFDRjtZQUNBaUMsdUJBQXVCN0MsT0FBT1k7UUFDaEMsR0FBRztJQUNMO0lBRUEsU0FBUzBFO1lBSVN2QyxxQkFHQUEsNkJBQ0Y2QywwQkFBQUEsaUJBR0NDO1FBVmYsTUFBTTlDLE1BQU1wRCxXQUFXcUQsT0FBTztRQUM5QixJQUFJLENBQUNELEtBQUssT0FBTztRQUVqQixNQUFNNkMsV0FBVTdDLHNCQUFBQSxJQUFJK0MsY0FBYyxjQUFsQi9DLDBDQUFBQSx5QkFBQUE7UUFDaEIsSUFBSSxDQUFDNkMsU0FBUyxPQUFPO1FBRXJCLE1BQU1DLFdBQVU5Qyw4QkFBQUEsSUFBSWdELHNCQUFzQixjQUExQmhELGtEQUFBQSxpQ0FBQUEsS0FBNkI2QyxRQUFRSSxRQUFRO1FBQzdELE1BQU1oRyxTQUFRNEYsa0JBQUFBLFFBQVFLLE1BQU0sY0FBZEwsdUNBQUFBLDJCQUFBQSxnQkFBZ0JNLFFBQVEsY0FBeEJOLCtDQUFBQSw4QkFBQUE7UUFDZCxJQUFJLENBQUNDLFdBQVcsQ0FBQzdGLE9BQU8sT0FBTztRQUUvQixNQUFNWSxTQUFTaUYsZ0JBQUFBLFFBQVFNLElBQUksY0FBWk4sb0NBQUQsYUFBdUIsQ0FBQzdGLE1BQU07UUFDNUMsSUFBSVksVUFBVSxRQUFRQSxVQUFVcUIsV0FBVyxPQUFPO1FBQ2xELE9BQU8sT0FBT3JCLFVBQVUsV0FBV0EsUUFBUXNCLE9BQU90QjtJQUNwRDtJQUVBLE1BQU13RixpQkFBaUI5SCw4Q0FBT0EsQ0FBYztRQUMxQyxJQUFJTSxjQUFjQSxXQUFXOEQsTUFBTSxFQUFFLE9BQU85RDtZQUNuQkQ7UUFBekIsTUFBTTBILE9BQU9DLE9BQU9ELElBQUksQ0FBQzFILENBQUFBLFlBQUFBLG9CQUFBQSw4QkFBQUEsT0FBUyxDQUFDLEVBQUUsY0FBWkEsdUJBQUFBLFlBQWdCLENBQUM7UUFDMUMsT0FBTzBILEtBQUt4RyxHQUFHLENBQUMsQ0FBQ0ksUUFBVztnQkFBRUE7WUFBTTtJQUN0QyxHQUFHO1FBQUNyQjtRQUFZRDtLQUFRO0lBRXhCLE1BQU00SCxnQkFBZ0JqSSw4Q0FBT0EsQ0FDM0IsSUFBTztZQUNMa0ksV0FBVztZQUNYQyxpQkFBaUI7WUFDakJDLFVBQVU7WUFDVkMsWUFBWTtZQUNaeEcsUUFBUTtZQUNSeUcsZ0JBQWdCO1lBQ2hCQyxVQUFVO1FBQ1osSUFDQSxFQUFFO0lBR0osTUFBTUMsb0JBQW9CeEksOENBQU9BLENBQy9CLElBQU87WUFDTHlJLE9BQU87WUFDUEMsYUFBYTtZQUNiQyxjQUFjO1lBQ2RDLG1CQUFtQjtZQUNuQkMsWUFBWTtZQUVaQyx3QkFBd0I7WUFDeEJDLDRCQUE0QjtZQUM1QkMsMEJBQTBCO1lBQzFCQywyQkFBMkI7WUFDM0JDLHlCQUF5QjtZQUN6QkMsZ0JBQWdCO1lBRWhCLEdBQUl4SSx3QkFBQUEseUJBQUFBLGNBQWUsQ0FBQyxDQUFDO1FBQ3ZCLElBQ0E7UUFBQ0E7S0FBWTtJQUdmLE1BQU15SSxpQkFBaUI7UUFDckI7UUFDQTdJO0tBQ0QsQ0FDRXNCLE1BQU0sQ0FBQ3dILFNBQ1BDLElBQUksQ0FBQztJQUVSLE1BQU1DLHFCQUFxQnZKLDhDQUFPQSxDQUFDO1FBQ2pDLE9BQU87WUFDTFEsUUFBUTtZQUNSLHFCQUFxQjtZQUNyQiwrQkFBK0I7WUFDL0IsMENBQTBDO1lBQzFDLDBDQUEwQztZQUMxQywyQ0FBMkM7UUFDN0M7SUFDRixHQUFHLEVBQUU7SUFFTCxxQkFDRSw4REFBQ2dKO1FBQ0NqSixXQUFVO1FBQ1ZpQyxPQUFPO1lBQUVoQztRQUFPO1FBQ2hCaUosa0JBQWtCM0M7UUFDbEI0QyxnQkFBZ0JyQzs7WUFFZjNHLHNCQUNDLDhEQUFDOEk7Z0JBQUlqSixXQUFVOzBCQUNaRzs7Ozs7dUJBRUQ7MEJBRUosOERBQUM4STtnQkFBK0JoSCxPQUFPK0c7MkRBQXZCSDs7Ozs7O2tDQVNkLDhEQUFDckosc0RBQVdBO3dCQUNWTSxTQUFTQTt3QkFDVEMsWUFBWXdIO3dCQUNaRyxlQUFlQTt3QkFDZnRILGFBQWE2SDt3QkFDYi9ILFNBQVNBO3dCQUNUSSxhQUFhLENBQUNvQzs0QkFDWjVCLFdBQVdxRCxPQUFPLEdBQUd6QixFQUFFd0IsR0FBRzs0QkFDMUI1RCx3QkFBQUEsa0NBQUFBLFlBQWNvQzt3QkFDaEI7d0JBQ0FuQyxpQkFBaUJBO3dCQUNqQkMsZUFBZUE7d0JBQ2ZDLG9CQUFvQkE7d0JBQ3BCQyxlQUFlQTt3QkFDZkMscUJBQXFCQTt3QkFDckJDLGVBQWU2Qjt3QkFDZjJHLFVBQ0UvSSxhQUNJLENBQUNnSjtnQ0FDYUE7NEJBQVosTUFBTUMsT0FBTUQsVUFBQUEsRUFBRS9CLElBQUksY0FBTitCLDhCQUFBQSxPQUFRLENBQUNoSixXQUFXOzRCQUNoQyxJQUFJLE9BQU9pSixRQUFRLFlBQVlBLElBQUl6RixNQUFNLEVBQUUsT0FBT3lGOzRCQUNsRCxJQUFJLE9BQU9BLFFBQVEsVUFBVSxPQUFPakcsT0FBT2lHOzRCQUMzQyxPQUFPQyxLQUFLQyxTQUFTLENBQUNILEVBQUUvQixJQUFJO3dCQUM5QixJQUNBbEU7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1oQjtHQS9WZ0J2RDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL2hiYy9IYmNBZ1RhYmxlLnRzeD8yYmUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEhiY0FnVGFibGUudHN4XG5cInVzZSBjbGllbnRcIlxuXG5pbXBvcnQgXCJhZy1ncmlkLWNvbW11bml0eS9zdHlsZXMvYWctZ3JpZC5jc3NcIlxuaW1wb3J0IFwiYWctZ3JpZC1jb21tdW5pdHkvc3R5bGVzL2FnLXRoZW1lLXF1YXJ0ei5jc3NcIlxuXG5pbXBvcnQgeyBBbGxDb21tdW5pdHlNb2R1bGUsIE1vZHVsZVJlZ2lzdHJ5IH0gZnJvbSBcImFnLWdyaWQtY29tbXVuaXR5XCJcbmltcG9ydCB0eXBlIHsgQ29sRGVmLCBHcmlkQXBpLCBHcmlkT3B0aW9ucyB9IGZyb20gXCJhZy1ncmlkLWNvbW11bml0eVwiXG5pbXBvcnQgdHlwZSB7IENlbGxDbGlja2VkRXZlbnQsIENlbGxEb3VibGVDbGlja2VkRXZlbnQgfSBmcm9tIFwiYWctZ3JpZC1jb21tdW5pdHlcIlxuaW1wb3J0IHR5cGUgeyBDZWxsS2V5RG93bkV2ZW50IH0gZnJvbSBcImFnLWdyaWQtY29tbXVuaXR5XCJcbmltcG9ydCB0eXBlIHsgRmlsdGVyQ2hhbmdlZEV2ZW50LCBHcmlkUmVhZHlFdmVudCwgU29ydENoYW5nZWRFdmVudCB9IGZyb20gXCJhZy1ncmlkLWNvbW11bml0eVwiXG5pbXBvcnQgdHlwZSB7IFNlbGVjdGlvbkNoYW5nZWRFdmVudCB9IGZyb20gXCJhZy1ncmlkLWNvbW11bml0eVwiXG5pbXBvcnQgeyBBZ0dyaWRSZWFjdCB9IGZyb20gXCJhZy1ncmlkLXJlYWN0XCJcbmltcG9ydCB0eXBlIHsgQ1NTUHJvcGVydGllcyB9IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgdHlwZSB7IEtleWJvYXJkRXZlbnQgYXMgUmVhY3RLZXlib2FyZEV2ZW50IH0gZnJvbSBcInJlYWN0XCJcbmltcG9ydCB7IHVzZU1lbW8sIHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiXG5cbmxldCBhZ0dyaWRSZWdpc3RlcmVkID0gZmFsc2VcbmlmICghYWdHcmlkUmVnaXN0ZXJlZCkge1xuICBNb2R1bGVSZWdpc3RyeS5yZWdpc3Rlck1vZHVsZXMoW0FsbENvbW11bml0eU1vZHVsZV0pXG4gIGFnR3JpZFJlZ2lzdGVyZWQgPSB0cnVlXG59XG5cbmV4cG9ydCB0eXBlIEhiY0FnVGFibGVQcm9wczxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+ID0ge1xuICByb3dEYXRhOiBUW11cbiAgY29sdW1uRGVmcz86IENvbERlZjxUPltdXG4gIGNsYXNzTmFtZT86IHN0cmluZ1xuICBoZWlnaHQ/OiBudW1iZXIgfCBzdHJpbmdcbiAgbG9hZGluZz86IGJvb2xlYW5cbiAgZXJyb3I/OiBzdHJpbmcgfCBudWxsXG4gIGdyaWRPcHRpb25zPzogR3JpZE9wdGlvbnM8VD5cbiAgcm93SWRGaWVsZD86IEV4dHJhY3Q8a2V5b2YgVCwgc3RyaW5nPlxuICBvbkdyaWRSZWFkeT86IChldmVudDogR3JpZFJlYWR5RXZlbnQ8VD4pID0+IHZvaWRcbiAgb25GaWx0ZXJDaGFuZ2VkPzogKGV2ZW50OiBGaWx0ZXJDaGFuZ2VkRXZlbnQ8VD4pID0+IHZvaWRcbiAgb25Tb3J0Q2hhbmdlZD86IChldmVudDogU29ydENoYW5nZWRFdmVudDxUPikgPT4gdm9pZFxuICBvblNlbGVjdGlvbkNoYW5nZWQ/OiAoZXZlbnQ6IFNlbGVjdGlvbkNoYW5nZWRFdmVudDxUPikgPT4gdm9pZFxuICBvbkNlbGxDbGlja2VkPzogKGV2ZW50OiBDZWxsQ2xpY2tlZEV2ZW50PFQ+KSA9PiB2b2lkXG4gIG9uQ2VsbERvdWJsZUNsaWNrZWQ/OiAoZXZlbnQ6IENlbGxEb3VibGVDbGlja2VkRXZlbnQ8VD4pID0+IHZvaWRcbiAgb25DZWxsS2V5RG93bj86IChldmVudDogQ2VsbEtleURvd25FdmVudDxUPikgPT4gdm9pZFxuICBvbkZpbHRlclBhc3RlPzogKGNvbElkOiBzdHJpbmcpID0+IHZvaWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEhiY0FnVGFibGU8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+Pih7XG4gIHJvd0RhdGEsXG4gIGNvbHVtbkRlZnMsXG4gIGNsYXNzTmFtZSxcbiAgaGVpZ2h0ID0gXCIxMDAlXCIsXG4gIGxvYWRpbmcsXG4gIGVycm9yLFxuICBncmlkT3B0aW9ucyxcbiAgcm93SWRGaWVsZCxcbiAgb25HcmlkUmVhZHksXG4gIG9uRmlsdGVyQ2hhbmdlZCxcbiAgb25Tb3J0Q2hhbmdlZCxcbiAgb25TZWxlY3Rpb25DaGFuZ2VkLFxuICBvbkNlbGxDbGlja2VkLFxuICBvbkNlbGxEb3VibGVDbGlja2VkLFxuICBvbkNlbGxLZXlEb3duLFxuICBvbkZpbHRlclBhc3RlLFxufTogSGJjQWdUYWJsZVByb3BzPFQ+KSB7XG4gIGNvbnN0IGdyaWRBcGlSZWYgPSB1c2VSZWY8R3JpZEFwaTxUPiB8IG51bGw+KG51bGwpXG4gIGNvbnN0IGNvbHVtbkZpbHRlclR5cGVCeUNvbElkID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcDxzdHJpbmcsIHVua25vd24+KClcbiAgICBmb3IgKGNvbnN0IGRlZiBvZiBjb2x1bW5EZWZzID8/IFtdKSB7XG4gICAgICBjb25zdCBjb2xJZCA9IChkZWYuY29sSWQgPz8gZGVmLmZpZWxkKSBhcyBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICAgIGlmICghY29sSWQpIGNvbnRpbnVlXG4gICAgICBtYXAuc2V0KGNvbElkLCBkZWYuZmlsdGVyKVxuICAgIH1cbiAgICByZXR1cm4gbWFwXG4gIH0sIFtjb2x1bW5EZWZzXSlcblxuICBhc3luYyBmdW5jdGlvbiBjb3B5VGV4dCh0ZXh0OiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKG5hdmlnYXRvcj8uY2xpcGJvYXJkPy53cml0ZVRleHQpIHtcbiAgICAgICAgYXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBpZ25vcmUgYW5kIGZhbGwgYmFja1xuICAgIH1cblxuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpXG4gICAgZWwudmFsdWUgPSB0ZXh0XG4gICAgZWwuc2V0QXR0cmlidXRlKFwicmVhZG9ubHlcIiwgXCJ0cnVlXCIpXG4gICAgZWwuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCJcbiAgICBlbC5zdHlsZS50b3AgPSBcIi05OTk5cHhcIlxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpXG4gICAgZWwuc2VsZWN0KClcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZChcImNvcHlcIilcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ2VsbEtleURvd24oZTogQ2VsbEtleURvd25FdmVudDxUPikge1xuICAgIG9uQ2VsbEtleURvd24/LihlKVxuXG4gICAgY29uc3QgZXYgPSBlLmV2ZW50IGFzIEtleWJvYXJkRXZlbnQgfCB1bmRlZmluZWRcbiAgICBpZiAoIWV2KSByZXR1cm5cblxuICAgIGNvbnN0IGtleSA9IGV2LmtleT8udG9Mb3dlckNhc2UoKVxuICAgIGNvbnN0IGlzQ29weSA9IChldi5tZXRhS2V5IHx8IGV2LmN0cmxLZXkpICYmIGtleSA9PT0gXCJjXCIgJiYgIWV2LnNoaWZ0S2V5ICYmICFldi5hbHRLZXlcbiAgICBpZiAoIWlzQ29weSkgcmV0dXJuXG5cbiAgICBjb25zdCB2YWx1ZSA9IGUudmFsdWVcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gICAgY29uc3QgdGV4dCA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogU3RyaW5nKHZhbHVlKVxuXG4gICAgZXYucHJldmVudERlZmF1bHQoKVxuICAgIHZvaWQgY29weVRleHQodGV4dClcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRGbG9hdGluZ0ZpbHRlckNvbHVtbklkKHRhcmdldDogRXZlbnRUYXJnZXQgfCBudWxsKTogc3RyaW5nIHwgbnVsbCB7XG4gICAgaWYgKCF0YXJnZXQgfHwgISh0YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHJldHVybiBudWxsXG4gICAgY29uc3QgZGlyZWN0ID0gdGFyZ2V0LmNsb3Nlc3QoXCJbY29sLWlkXVwiKT8uZ2V0QXR0cmlidXRlKFwiY29sLWlkXCIpXG4gICAgaWYgKGRpcmVjdCAmJiBkaXJlY3QubGVuZ3RoKSByZXR1cm4gZGlyZWN0XG5cbiAgICBjb25zdCBmbG9hdGluZyA9IHRhcmdldC5jbG9zZXN0KFwiLmFnLWZsb2F0aW5nLWZpbHRlclwiKVxuICAgIGlmICghZmxvYXRpbmcpIHJldHVybiBudWxsXG5cbiAgICBjb25zdCBoZWFkZXJDZWxsID0gdGFyZ2V0LmNsb3Nlc3QoXCIuYWctaGVhZGVyLWNlbGxcIilcbiAgICBjb25zdCBjb2xJZCA9IGhlYWRlckNlbGw/LmdldEF0dHJpYnV0ZShcImNvbC1pZFwiKVxuICAgIHJldHVybiBjb2xJZCAmJiBjb2xJZC5sZW5ndGggPyBjb2xJZCA6IG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEVxdWFsc0ZvclRleHRGaWx0ZXIoY29sSWQ6IHN0cmluZywgZmlsdGVyVGV4dD86IHN0cmluZykge1xuICAgIGNvbnN0IGFwaSA9IGdyaWRBcGlSZWYuY3VycmVudFxuICAgIGlmICghYXBpKSByZXR1cm5cblxuICAgIGNvbnN0IG1vZGVsID0gKGFwaS5nZXRGaWx0ZXJNb2RlbCgpIGFzIFJlY29yZDxzdHJpbmcsIGFueT4pID8/IHt9XG4gICAgY29uc3QgZXhpc3RpbmcgPSBtb2RlbFtjb2xJZF1cbiAgICBjb25zdCBuZXh0VGV4dCA9IHR5cGVvZiBmaWx0ZXJUZXh0ID09PSBcInN0cmluZ1wiID8gZmlsdGVyVGV4dCA6IGV4aXN0aW5nPy5maWx0ZXJcbiAgICBpZiAodHlwZW9mIG5leHRUZXh0ICE9PSBcInN0cmluZ1wiKSByZXR1cm5cbiAgICBjb25zdCB0cmltbWVkID0gbmV4dFRleHQudHJpbSgpXG4gICAgaWYgKCF0cmltbWVkKSByZXR1cm5cblxuICAgIGNvbnN0IGV4aXN0aW5nVHlwZSA9IGV4aXN0aW5nPy50eXBlID8gU3RyaW5nKGV4aXN0aW5nLnR5cGUpLnRvTG93ZXJDYXNlKCkgOiBcIlwiXG4gICAgY29uc3QgZXhpc3RpbmdWYWx1ZSA9IHR5cGVvZiBleGlzdGluZz8uZmlsdGVyID09PSBcInN0cmluZ1wiID8gZXhpc3RpbmcuZmlsdGVyLnRyaW0oKSA6IFwiXCJcbiAgICBpZiAoZXhpc3RpbmdUeXBlID09PSBcImVxdWFsc1wiICYmIGV4aXN0aW5nVmFsdWUgPT09IHRyaW1tZWQpIHJldHVyblxuXG4gICAgYXBpLnNldEZpbHRlck1vZGVsKHtcbiAgICAgIC4uLm1vZGVsLFxuICAgICAgW2NvbElkXToge1xuICAgICAgICAuLi4oZXhpc3RpbmcgPz8ge30pLFxuICAgICAgICBmaWx0ZXJUeXBlOiAoZXhpc3Rpbmc/LmZpbHRlclR5cGUgYXMgc3RyaW5nIHwgdW5kZWZpbmVkKSA/PyBcInRleHRcIixcbiAgICAgICAgdHlwZTogXCJlcXVhbHNcIixcbiAgICAgICAgZmlsdGVyOiB0cmltbWVkLFxuICAgICAgfSxcbiAgICB9KVxuICAgIGFwaS5vbkZpbHRlckNoYW5nZWQ/LigpXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZURhdGVGcm9tVGV4dChpbnB1dDogc3RyaW5nKSB7XG4gICAgY29uc3QgdGV4dCA9IGlucHV0LnRyaW0oKVxuICAgIGlmICghdGV4dCkgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IGlzb01hdGNoID0gL14oXFxkezR9LVxcZHsyfS1cXGR7Mn0pLy5leGVjKHRleHQpXG4gICAgaWYgKGlzb01hdGNoKSByZXR1cm4gaXNvTWF0Y2hbMV1cblxuICAgIGNvbnN0IG1zID0gRGF0ZS5wYXJzZSh0ZXh0KVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG1zKSkgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShtcylcbiAgICBjb25zdCB5eXl5ID0gU3RyaW5nKGQuZ2V0RnVsbFllYXIoKSkucGFkU3RhcnQoNCwgXCIwXCIpXG4gICAgY29uc3QgbW0gPSBTdHJpbmcoZC5nZXRNb250aCgpICsgMSkucGFkU3RhcnQoMiwgXCIwXCIpXG4gICAgY29uc3QgZGQgPSBTdHJpbmcoZC5nZXREYXRlKCkpLnBhZFN0YXJ0KDIsIFwiMFwiKVxuICAgIHJldHVybiBgJHt5eXl5fS0ke21tfS0ke2RkfWBcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEVxdWFsc0ZvckRhdGVGaWx0ZXIoY29sSWQ6IHN0cmluZywgZmlsdGVyVGV4dD86IHN0cmluZykge1xuICAgIGNvbnN0IGFwaSA9IGdyaWRBcGlSZWYuY3VycmVudFxuICAgIGlmICghYXBpKSByZXR1cm5cblxuICAgIGNvbnN0IG1vZGVsID0gKGFwaS5nZXRGaWx0ZXJNb2RlbCgpIGFzIFJlY29yZDxzdHJpbmcsIGFueT4pID8/IHt9XG4gICAgY29uc3QgZXhpc3RpbmcgPSBtb2RlbFtjb2xJZF1cblxuICAgIGNvbnN0IG5leHRUZXh0ID0gdHlwZW9mIGZpbHRlclRleHQgPT09IFwic3RyaW5nXCIgPyBmaWx0ZXJUZXh0IDogZXhpc3Rpbmc/LmRhdGVGcm9tXG4gICAgaWYgKHR5cGVvZiBuZXh0VGV4dCAhPT0gXCJzdHJpbmdcIikgcmV0dXJuXG5cbiAgICBjb25zdCBkYXRlRnJvbSA9IHBhcnNlRGF0ZUZyb21UZXh0KG5leHRUZXh0KVxuICAgIGlmICghZGF0ZUZyb20pIHJldHVyblxuXG4gICAgY29uc3QgZXhpc3RpbmdUeXBlID0gZXhpc3Rpbmc/LnR5cGUgPyBTdHJpbmcoZXhpc3RpbmcudHlwZSkudG9Mb3dlckNhc2UoKSA6IFwiXCJcbiAgICBjb25zdCBleGlzdGluZ0RhdGVGcm9tID0gdHlwZW9mIGV4aXN0aW5nPy5kYXRlRnJvbSA9PT0gXCJzdHJpbmdcIiA/IGV4aXN0aW5nLmRhdGVGcm9tLnRyaW0oKSA6IFwiXCJcbiAgICBpZiAoZXhpc3RpbmdUeXBlID09PSBcImVxdWFsc1wiICYmIGV4aXN0aW5nRGF0ZUZyb20gPT09IGRhdGVGcm9tKSByZXR1cm5cblxuICAgIGFwaS5zZXRGaWx0ZXJNb2RlbCh7XG4gICAgICAuLi5tb2RlbCxcbiAgICAgIFtjb2xJZF06IHtcbiAgICAgICAgLi4uKGV4aXN0aW5nID8/IHt9KSxcbiAgICAgICAgZmlsdGVyVHlwZTogXCJkYXRlXCIsXG4gICAgICAgIHR5cGU6IFwiZXF1YWxzXCIsXG4gICAgICAgIGRhdGVGcm9tLFxuICAgICAgfSxcbiAgICB9KVxuICAgIGFwaS5vbkZpbHRlckNoYW5nZWQ/LigpXG4gIH1cblxuICBmdW5jdGlvbiBnZXRQcmVmZXJyZWRGaWx0ZXJUeXBlKGNvbElkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBhcGkgPSBncmlkQXBpUmVmLmN1cnJlbnRcbiAgICBjb25zdCBtb2RlbCA9IChhcGk/LmdldEZpbHRlck1vZGVsKCkgYXMgUmVjb3JkPHN0cmluZywgYW55PikgPz8ge31cbiAgICBjb25zdCBleGlzdGluZyA9IG1vZGVsW2NvbElkXVxuICAgIGNvbnN0IGV4aXN0aW5nRmlsdGVyVHlwZSA9IHR5cGVvZiBleGlzdGluZz8uZmlsdGVyVHlwZSA9PT0gXCJzdHJpbmdcIiA/IGV4aXN0aW5nLmZpbHRlclR5cGUgOiB1bmRlZmluZWRcbiAgICBpZiAoZXhpc3RpbmdGaWx0ZXJUeXBlKSByZXR1cm4gZXhpc3RpbmdGaWx0ZXJUeXBlXG5cbiAgICBjb25zdCBjb2xGaWx0ZXIgPSBjb2x1bW5GaWx0ZXJUeXBlQnlDb2xJZC5nZXQoY29sSWQpXG4gICAgaWYgKGNvbEZpbHRlciA9PT0gXCJhZ0RhdGVDb2x1bW5GaWx0ZXJcIikgcmV0dXJuIFwiZGF0ZVwiXG4gICAgaWYgKGNvbEZpbHRlciA9PT0gXCJhZ051bWJlckNvbHVtbkZpbHRlclwiKSByZXR1cm4gXCJudW1iZXJcIlxuICAgIHJldHVybiBcInRleHRcIlxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bkNhcHR1cmUoZXY6IFJlYWN0S2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnN0IGtleSA9IGV2LmtleT8udG9Mb3dlckNhc2UoKVxuICAgIGNvbnN0IGlzQ29weSA9IChldi5tZXRhS2V5IHx8IGV2LmN0cmxLZXkpICYmIGtleSA9PT0gXCJjXCIgJiYgIWV2LnNoaWZ0S2V5ICYmICFldi5hbHRLZXlcbiAgICBjb25zdCBpc1Bhc3RlID0gKGV2Lm1ldGFLZXkgfHwgZXYuY3RybEtleSkgJiYga2V5ID09PSBcInZcIiAmJiAhZXYuc2hpZnRLZXkgJiYgIWV2LmFsdEtleVxuXG4gICAgaWYgKCFpc0NvcHkgJiYgIWlzUGFzdGUpIHJldHVyblxuXG4gICAgY29uc3QgY29sSWQgPSBmaW5kRmxvYXRpbmdGaWx0ZXJDb2x1bW5JZChldi50YXJnZXQpXG4gICAgaWYgKCFjb2xJZCkge1xuICAgICAgaWYgKGlzQ29weSkge1xuICAgICAgICBjb25zdCB0ZXh0ID0gZ2V0Rm9jdXNlZENlbGxUZXh0KClcbiAgICAgICAgaWYgKCF0ZXh0KSByZXR1cm5cbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKVxuICAgICAgICB2b2lkIGNvcHlUZXh0KHRleHQpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoaXNQYXN0ZSkge1xuICAgICAgb25GaWx0ZXJQYXN0ZT8uKGNvbElkKVxuICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IGV2LnRhcmdldFxuICAgICAgICBjb25zdCB2YWx1ZSA9XG4gICAgICAgICAgZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50IHx8IGVsIGluc3RhbmNlb2YgSFRNTFRleHRBcmVhRWxlbWVudCA/IGVsLnZhbHVlIDogdW5kZWZpbmVkXG4gICAgICAgIGNvbnN0IGZpbHRlclR5cGUgPSBnZXRQcmVmZXJyZWRGaWx0ZXJUeXBlKGNvbElkKVxuICAgICAgICBpZiAoZmlsdGVyVHlwZSA9PT0gXCJkYXRlXCIpIHtcbiAgICAgICAgICBzZXRFcXVhbHNGb3JEYXRlRmlsdGVyKGNvbElkLCB2YWx1ZSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBzZXRFcXVhbHNGb3JUZXh0RmlsdGVyKGNvbElkLCB2YWx1ZSlcbiAgICAgIH0sIDQwKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGlzQ29weSkge1xuICAgICAgY29uc3QgdGV4dCA9IGdldEZvY3VzZWRDZWxsVGV4dCgpXG4gICAgICBpZiAoIXRleHQpIHJldHVyblxuICAgICAgZXYucHJldmVudERlZmF1bHQoKVxuICAgICAgdm9pZCBjb3B5VGV4dCh0ZXh0KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVBhc3RlQ2FwdHVyZShldjogUmVhY3QuQ2xpcGJvYXJkRXZlbnQpIHtcbiAgICBjb25zdCBjb2xJZCA9IGZpbmRGbG9hdGluZ0ZpbHRlckNvbHVtbklkKGV2LnRhcmdldClcbiAgICBpZiAoIWNvbElkKSByZXR1cm5cblxuICAgIG9uRmlsdGVyUGFzdGU/Lihjb2xJZClcbiAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCBlbCA9IGV2LnRhcmdldFxuICAgICAgY29uc3QgdmFsdWUgPSBlbCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgfHwgZWwgaW5zdGFuY2VvZiBIVE1MVGV4dEFyZWFFbGVtZW50ID8gZWwudmFsdWUgOiB1bmRlZmluZWRcbiAgICAgIGNvbnN0IGZpbHRlclR5cGUgPSBnZXRQcmVmZXJyZWRGaWx0ZXJUeXBlKGNvbElkKVxuICAgICAgaWYgKGZpbHRlclR5cGUgPT09IFwiZGF0ZVwiKSB7XG4gICAgICAgIHNldEVxdWFsc0ZvckRhdGVGaWx0ZXIoY29sSWQsIHZhbHVlKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHNldEVxdWFsc0ZvclRleHRGaWx0ZXIoY29sSWQsIHZhbHVlKVxuICAgIH0sIDQwKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Rm9jdXNlZENlbGxUZXh0KCk6IHN0cmluZyB8IG51bGwge1xuICAgIGNvbnN0IGFwaSA9IGdyaWRBcGlSZWYuY3VycmVudFxuICAgIGlmICghYXBpKSByZXR1cm4gbnVsbFxuXG4gICAgY29uc3QgZm9jdXNlZCA9IGFwaS5nZXRGb2N1c2VkQ2VsbD8uKClcbiAgICBpZiAoIWZvY3VzZWQpIHJldHVybiBudWxsXG5cbiAgICBjb25zdCByb3dOb2RlID0gYXBpLmdldERpc3BsYXllZFJvd0F0SW5kZXg/Lihmb2N1c2VkLnJvd0luZGV4KVxuICAgIGNvbnN0IGNvbElkID0gZm9jdXNlZC5jb2x1bW4/LmdldENvbElkPy4oKVxuICAgIGlmICghcm93Tm9kZSB8fCAhY29sSWQpIHJldHVybiBudWxsXG5cbiAgICBjb25zdCB2YWx1ZSA9IChyb3dOb2RlLmRhdGEgYXMgYW55KT8uW2NvbElkXVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbFxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IFN0cmluZyh2YWx1ZSlcbiAgfVxuXG4gIGNvbnN0IGF1dG9Db2x1bW5EZWZzID0gdXNlTWVtbzxDb2xEZWY8VD5bXT4oKCkgPT4ge1xuICAgIGlmIChjb2x1bW5EZWZzICYmIGNvbHVtbkRlZnMubGVuZ3RoKSByZXR1cm4gY29sdW1uRGVmc1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyb3dEYXRhPy5bMF0gPz8ge30pXG4gICAgcmV0dXJuIGtleXMubWFwKChmaWVsZCkgPT4gKHsgZmllbGQgfSkpIGFzIENvbERlZjxUPltdXG4gIH0sIFtjb2x1bW5EZWZzLCByb3dEYXRhXSlcblxuICBjb25zdCBkZWZhdWx0Q29sRGVmID0gdXNlTWVtbzxDb2xEZWY8VD4+KFxuICAgICgpID0+ICh7XG4gICAgICByZXNpemFibGU6IHRydWUsXG4gICAgICBzdXBwcmVzc01vdmFibGU6IGZhbHNlLFxuICAgICAgc29ydGFibGU6IHRydWUsXG4gICAgICB1blNvcnRJY29uOiB0cnVlLFxuICAgICAgZmlsdGVyOiB0cnVlLFxuICAgICAgZmxvYXRpbmdGaWx0ZXI6IHRydWUsXG4gICAgICBtaW5XaWR0aDogOTAsXG4gICAgfSksXG4gICAgW11cbiAgKVxuXG4gIGNvbnN0IG1lcmdlZEdyaWRPcHRpb25zID0gdXNlTWVtbzxHcmlkT3B0aW9uczxUPj4oXG4gICAgKCkgPT4gKHtcbiAgICAgIHRoZW1lOiBcImxlZ2FjeVwiLFxuICAgICAgYW5pbWF0ZVJvd3M6IHRydWUsXG4gICAgICByb3dTZWxlY3Rpb246IFwic2luZ2xlXCIsXG4gICAgICBzdXBwcmVzc0NlbGxGb2N1czogZmFsc2UsXG4gICAgICBwYWdpbmF0aW9uOiBmYWxzZSxcblxuICAgICAgc3VwcHJlc3NNb3ZhYmxlQ29sdW1uczogZmFsc2UsXG4gICAgICBhbHdheXNTaG93SG9yaXpvbnRhbFNjcm9sbDogdHJ1ZSxcbiAgICAgIHN1cHByZXNzSG9yaXpvbnRhbFNjcm9sbDogZmFsc2UsXG4gICAgICBzdXBwcmVzc1Jvd0NsaWNrU2VsZWN0aW9uOiB0cnVlLFxuICAgICAgZW5hYmxlQ2VsbFRleHRTZWxlY3Rpb246IHRydWUsXG4gICAgICBlbnN1cmVEb21PcmRlcjogdHJ1ZSxcblxuICAgICAgLi4uKGdyaWRPcHRpb25zID8/IHt9KSxcbiAgICB9KSxcbiAgICBbZ3JpZE9wdGlvbnNdXG4gIClcblxuICBjb25zdCBmaW5hbENsYXNzTmFtZSA9IFtcbiAgICBcImhiYy1hZy1ncmlkIGFnLXRoZW1lLXF1YXJ0ei1kYXJrIHctZnVsbCByb3VuZGVkLWxnIGJvcmRlciBib3JkZXItW2NvbG9yOnZhcigtLWNvbG9yLWJvcmRlcildIGJnLVtjb2xvcjp2YXIoLS1jb2xvci1jYXJkKV1cIixcbiAgICBjbGFzc05hbWUsXG4gIF1cbiAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgLmpvaW4oXCIgXCIpXG5cbiAgY29uc3QgZ3JpZENvbnRhaW5lclN0eWxlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICBcIi0tYWctYm9yZGVyLWNvbG9yXCI6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjE2KVwiLFxuICAgICAgXCItLWFnLXNlY29uZGFyeS1ib3JkZXItY29sb3JcIjogXCJyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTIpXCIsXG4gICAgICBcIi0tYWctaGVhZGVyLWNvbHVtbi1yZXNpemUtaGFuZGxlLWNvbG9yXCI6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjY1KVwiLFxuICAgICAgXCItLWFnLWhlYWRlci1jb2x1bW4tcmVzaXplLWhhbmRsZS13aWR0aFwiOiBcIjRweFwiLFxuICAgICAgXCItLWFnLWhlYWRlci1jb2x1bW4tcmVzaXplLWhhbmRsZS1oZWlnaHRcIjogXCI2MCVcIixcbiAgICB9IGFzIENTU1Byb3BlcnRpZXNcbiAgfSwgW10pXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9XCJ3LWZ1bGxcIlxuICAgICAgc3R5bGU9e3sgaGVpZ2h0IH19XG4gICAgICBvbktleURvd25DYXB0dXJlPXtoYW5kbGVLZXlEb3duQ2FwdHVyZX1cbiAgICAgIG9uUGFzdGVDYXB0dXJlPXtoYW5kbGVQYXN0ZUNhcHR1cmV9XG4gICAgPlxuICAgICAge2Vycm9yID8gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1iLTMgcm91bmRlZC1tZCBib3JkZXIgYm9yZGVyLXJlZC01MDAvNDAgYmctcmVkLTUwMC8xMCBweC0zIHB5LTIgdGV4dC1zbSB0ZXh0LXJlZC0yMDBcIj5cbiAgICAgICAgICB7ZXJyb3J9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKSA6IG51bGx9XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtmaW5hbENsYXNzTmFtZX0gc3R5bGU9e2dyaWRDb250YWluZXJTdHlsZX0+XG4gICAgICAgIDxzdHlsZSBqc3ggZ2xvYmFsPntgXG4gICAgICAgICAgLmhiYy1hZy1ncmlkIC5hZy1oZWFkZXItY2VsbC1yZXNpemUge1xuICAgICAgICAgICAgY3Vyc29yOiBjb2wtcmVzaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgICAuaGJjLWFnLWdyaWQgLmFnLWhlYWRlci1jZWxsLXJlc2l6ZTo6YWZ0ZXIge1xuICAgICAgICAgICAgY3Vyc29yOiBjb2wtcmVzaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgYH08L3N0eWxlPlxuICAgICAgICA8QWdHcmlkUmVhY3Q8VD5cbiAgICAgICAgICByb3dEYXRhPXtyb3dEYXRhfVxuICAgICAgICAgIGNvbHVtbkRlZnM9e2F1dG9Db2x1bW5EZWZzfVxuICAgICAgICAgIGRlZmF1bHRDb2xEZWY9e2RlZmF1bHRDb2xEZWZ9XG4gICAgICAgICAgZ3JpZE9wdGlvbnM9e21lcmdlZEdyaWRPcHRpb25zfVxuICAgICAgICAgIGxvYWRpbmc9e2xvYWRpbmd9XG4gICAgICAgICAgb25HcmlkUmVhZHk9eyhlKSA9PiB7XG4gICAgICAgICAgICBncmlkQXBpUmVmLmN1cnJlbnQgPSBlLmFwaVxuICAgICAgICAgICAgb25HcmlkUmVhZHk/LihlKVxuICAgICAgICAgIH19XG4gICAgICAgICAgb25GaWx0ZXJDaGFuZ2VkPXtvbkZpbHRlckNoYW5nZWR9XG4gICAgICAgICAgb25Tb3J0Q2hhbmdlZD17b25Tb3J0Q2hhbmdlZH1cbiAgICAgICAgICBvblNlbGVjdGlvbkNoYW5nZWQ9e29uU2VsZWN0aW9uQ2hhbmdlZH1cbiAgICAgICAgICBvbkNlbGxDbGlja2VkPXtvbkNlbGxDbGlja2VkfVxuICAgICAgICAgIG9uQ2VsbERvdWJsZUNsaWNrZWQ9e29uQ2VsbERvdWJsZUNsaWNrZWR9XG4gICAgICAgICAgb25DZWxsS2V5RG93bj17aGFuZGxlQ2VsbEtleURvd259XG4gICAgICAgICAgZ2V0Um93SWQ9e1xuICAgICAgICAgICAgcm93SWRGaWVsZFxuICAgICAgICAgICAgICA/IChwKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCByYXcgPSBwLmRhdGE/Lltyb3dJZEZpZWxkXVxuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByYXcgPT09IFwic3RyaW5nXCIgJiYgcmF3Lmxlbmd0aCkgcmV0dXJuIHJhd1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByYXcgPT09IFwibnVtYmVyXCIpIHJldHVybiBTdHJpbmcocmF3KVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHAuZGF0YSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJBbGxDb21tdW5pdHlNb2R1bGUiLCJNb2R1bGVSZWdpc3RyeSIsIkFnR3JpZFJlYWN0IiwidXNlTWVtbyIsInVzZVJlZiIsImFnR3JpZFJlZ2lzdGVyZWQiLCJyZWdpc3Rlck1vZHVsZXMiLCJIYmNBZ1RhYmxlIiwicm93RGF0YSIsImNvbHVtbkRlZnMiLCJjbGFzc05hbWUiLCJoZWlnaHQiLCJsb2FkaW5nIiwiZXJyb3IiLCJncmlkT3B0aW9ucyIsInJvd0lkRmllbGQiLCJvbkdyaWRSZWFkeSIsIm9uRmlsdGVyQ2hhbmdlZCIsIm9uU29ydENoYW5nZWQiLCJvblNlbGVjdGlvbkNoYW5nZWQiLCJvbkNlbGxDbGlja2VkIiwib25DZWxsRG91YmxlQ2xpY2tlZCIsIm9uQ2VsbEtleURvd24iLCJvbkZpbHRlclBhc3RlIiwiZ3JpZEFwaVJlZiIsImNvbHVtbkZpbHRlclR5cGVCeUNvbElkIiwibWFwIiwiTWFwIiwiZGVmIiwiY29sSWQiLCJmaWVsZCIsInNldCIsImZpbHRlciIsImNvcHlUZXh0IiwidGV4dCIsIm5hdmlnYXRvciIsImNsaXBib2FyZCIsIndyaXRlVGV4dCIsImVsIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidmFsdWUiLCJzZXRBdHRyaWJ1dGUiLCJzdHlsZSIsInBvc2l0aW9uIiwidG9wIiwiYm9keSIsImFwcGVuZENoaWxkIiwic2VsZWN0IiwiZXhlY0NvbW1hbmQiLCJyZW1vdmVDaGlsZCIsImhhbmRsZUNlbGxLZXlEb3duIiwiZSIsImV2IiwiZXZlbnQiLCJrZXkiLCJ0b0xvd2VyQ2FzZSIsImlzQ29weSIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJ1bmRlZmluZWQiLCJTdHJpbmciLCJwcmV2ZW50RGVmYXVsdCIsImZpbmRGbG9hdGluZ0ZpbHRlckNvbHVtbklkIiwidGFyZ2V0IiwiSFRNTEVsZW1lbnQiLCJkaXJlY3QiLCJjbG9zZXN0IiwiZ2V0QXR0cmlidXRlIiwibGVuZ3RoIiwiZmxvYXRpbmciLCJoZWFkZXJDZWxsIiwic2V0RXF1YWxzRm9yVGV4dEZpbHRlciIsImZpbHRlclRleHQiLCJhcGkiLCJjdXJyZW50IiwibW9kZWwiLCJnZXRGaWx0ZXJNb2RlbCIsImV4aXN0aW5nIiwibmV4dFRleHQiLCJ0cmltbWVkIiwidHJpbSIsImV4aXN0aW5nVHlwZSIsInR5cGUiLCJleGlzdGluZ1ZhbHVlIiwic2V0RmlsdGVyTW9kZWwiLCJmaWx0ZXJUeXBlIiwicGFyc2VEYXRlRnJvbVRleHQiLCJpbnB1dCIsImlzb01hdGNoIiwiZXhlYyIsIm1zIiwiRGF0ZSIsInBhcnNlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJkIiwieXl5eSIsImdldEZ1bGxZZWFyIiwicGFkU3RhcnQiLCJtbSIsImdldE1vbnRoIiwiZGQiLCJnZXREYXRlIiwic2V0RXF1YWxzRm9yRGF0ZUZpbHRlciIsImRhdGVGcm9tIiwiZXhpc3RpbmdEYXRlRnJvbSIsImdldFByZWZlcnJlZEZpbHRlclR5cGUiLCJleGlzdGluZ0ZpbHRlclR5cGUiLCJjb2xGaWx0ZXIiLCJnZXQiLCJoYW5kbGVLZXlEb3duQ2FwdHVyZSIsImlzUGFzdGUiLCJnZXRGb2N1c2VkQ2VsbFRleHQiLCJ3aW5kb3ciLCJzZXRUaW1lb3V0IiwiSFRNTElucHV0RWxlbWVudCIsIkhUTUxUZXh0QXJlYUVsZW1lbnQiLCJoYW5kbGVQYXN0ZUNhcHR1cmUiLCJmb2N1c2VkIiwicm93Tm9kZSIsImdldEZvY3VzZWRDZWxsIiwiZ2V0RGlzcGxheWVkUm93QXRJbmRleCIsInJvd0luZGV4IiwiY29sdW1uIiwiZ2V0Q29sSWQiLCJkYXRhIiwiYXV0b0NvbHVtbkRlZnMiLCJrZXlzIiwiT2JqZWN0IiwiZGVmYXVsdENvbERlZiIsInJlc2l6YWJsZSIsInN1cHByZXNzTW92YWJsZSIsInNvcnRhYmxlIiwidW5Tb3J0SWNvbiIsImZsb2F0aW5nRmlsdGVyIiwibWluV2lkdGgiLCJtZXJnZWRHcmlkT3B0aW9ucyIsInRoZW1lIiwiYW5pbWF0ZVJvd3MiLCJyb3dTZWxlY3Rpb24iLCJzdXBwcmVzc0NlbGxGb2N1cyIsInBhZ2luYXRpb24iLCJzdXBwcmVzc01vdmFibGVDb2x1bW5zIiwiYWx3YXlzU2hvd0hvcml6b250YWxTY3JvbGwiLCJzdXBwcmVzc0hvcml6b250YWxTY3JvbGwiLCJzdXBwcmVzc1Jvd0NsaWNrU2VsZWN0aW9uIiwiZW5hYmxlQ2VsbFRleHRTZWxlY3Rpb24iLCJlbnN1cmVEb21PcmRlciIsImZpbmFsQ2xhc3NOYW1lIiwiQm9vbGVhbiIsImpvaW4iLCJncmlkQ29udGFpbmVyU3R5bGUiLCJkaXYiLCJvbktleURvd25DYXB0dXJlIiwib25QYXN0ZUNhcHR1cmUiLCJnZXRSb3dJZCIsInAiLCJyYXciLCJKU09OIiwic3RyaW5naWZ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/hbc/HbcAgTable.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/styled-jsx/dist/index/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/styled-jsx/dist/index/index.js ***!
  \*****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n__webpack_require__(/*! client-only */ \"(app-pages-browser)/./node_modules/next/dist/compiled/client-only/index.js\");\nvar React = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar React__default = /*#__PURE__*/ _interopDefaultLegacy(React);\n_c = React__default;\n/*\nBased on Glamor's sheet\nhttps://github.com/threepointone/glamor/blob/667b480d31b3721a905021b26e1290ce92ca2879/src/sheet.js\n*/ function _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nvar isProd = typeof process !== \"undefined\" && process.env && \"development\" === \"production\";\nvar isString = function(o) {\n    return Object.prototype.toString.call(o) === \"[object String]\";\n};\nvar StyleSheet = /*#__PURE__*/ function() {\n    function StyleSheet(param) {\n        var ref = param === void 0 ? {} : param, _name = ref.name, name = _name === void 0 ? \"stylesheet\" : _name, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? isProd : _optimizeForSpeed;\n        invariant$1(isString(name), \"`name` must be a string\");\n        this._name = name;\n        this._deletedRulePlaceholder = \"#\" + name + \"-deleted-rule____{}\";\n        invariant$1(typeof optimizeForSpeed === \"boolean\", \"`optimizeForSpeed` must be a boolean\");\n        this._optimizeForSpeed = optimizeForSpeed;\n        this._serverSheet = undefined;\n        this._tags = [];\n        this._injected = false;\n        this._rulesCount = 0;\n        var node = typeof window !== \"undefined\" && document.querySelector('meta[property=\"csp-nonce\"]');\n        this._nonce = node ? node.getAttribute(\"content\") : null;\n    }\n    var _proto = StyleSheet.prototype;\n    _proto.setOptimizeForSpeed = function setOptimizeForSpeed(bool) {\n        invariant$1(typeof bool === \"boolean\", \"`setOptimizeForSpeed` accepts a boolean\");\n        invariant$1(this._rulesCount === 0, \"optimizeForSpeed cannot be when rules have already been inserted\");\n        this.flush();\n        this._optimizeForSpeed = bool;\n        this.inject();\n    };\n    _proto.isOptimizeForSpeed = function isOptimizeForSpeed() {\n        return this._optimizeForSpeed;\n    };\n    _proto.inject = function inject() {\n        var _this = this;\n        invariant$1(!this._injected, \"sheet already injected\");\n        this._injected = true;\n        if (typeof window !== \"undefined\" && this._optimizeForSpeed) {\n            this._tags[0] = this.makeStyleTag(this._name);\n            this._optimizeForSpeed = \"insertRule\" in this.getSheet();\n            if (!this._optimizeForSpeed) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: optimizeForSpeed mode not supported falling back to standard mode.\");\n                }\n                this.flush();\n                this._injected = true;\n            }\n            return;\n        }\n        this._serverSheet = {\n            cssRules: [],\n            insertRule: function(rule, index) {\n                if (typeof index === \"number\") {\n                    _this._serverSheet.cssRules[index] = {\n                        cssText: rule\n                    };\n                } else {\n                    _this._serverSheet.cssRules.push({\n                        cssText: rule\n                    });\n                }\n                return index;\n            },\n            deleteRule: function(index) {\n                _this._serverSheet.cssRules[index] = null;\n            }\n        };\n    };\n    _proto.getSheetForTag = function getSheetForTag(tag) {\n        if (tag.sheet) {\n            return tag.sheet;\n        }\n        // this weirdness brought to you by firefox\n        for(var i = 0; i < document.styleSheets.length; i++){\n            if (document.styleSheets[i].ownerNode === tag) {\n                return document.styleSheets[i];\n            }\n        }\n    };\n    _proto.getSheet = function getSheet() {\n        return this.getSheetForTag(this._tags[this._tags.length - 1]);\n    };\n    _proto.insertRule = function insertRule(rule, index) {\n        invariant$1(isString(rule), \"`insertRule` accepts only strings\");\n        if (typeof window === \"undefined\") {\n            if (typeof index !== \"number\") {\n                index = this._serverSheet.cssRules.length;\n            }\n            this._serverSheet.insertRule(rule, index);\n            return this._rulesCount++;\n        }\n        if (this._optimizeForSpeed) {\n            var sheet = this.getSheet();\n            if (typeof index !== \"number\") {\n                index = sheet.cssRules.length;\n            }\n            // this weirdness for perf, and chrome's weird bug\n            // https://stackoverflow.com/questions/20007992/chrome-suddenly-stopped-accepting-insertrule\n            try {\n                sheet.insertRule(rule, index);\n            } catch (error) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: illegal rule: \\n\\n\" + rule + \"\\n\\nSee https://stackoverflow.com/q/20007992 for more info\");\n                }\n                return -1;\n            }\n        } else {\n            var insertionPoint = this._tags[index];\n            this._tags.push(this.makeStyleTag(this._name, rule, insertionPoint));\n        }\n        return this._rulesCount++;\n    };\n    _proto.replaceRule = function replaceRule(index, rule) {\n        if (this._optimizeForSpeed || typeof window === \"undefined\") {\n            var sheet = typeof window !== \"undefined\" ? this.getSheet() : this._serverSheet;\n            if (!rule.trim()) {\n                rule = this._deletedRulePlaceholder;\n            }\n            if (!sheet.cssRules[index]) {\n                // @TBD Should we throw an error?\n                return index;\n            }\n            sheet.deleteRule(index);\n            try {\n                sheet.insertRule(rule, index);\n            } catch (error) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: illegal rule: \\n\\n\" + rule + \"\\n\\nSee https://stackoverflow.com/q/20007992 for more info\");\n                }\n                // In order to preserve the indices we insert a deleteRulePlaceholder\n                sheet.insertRule(this._deletedRulePlaceholder, index);\n            }\n        } else {\n            var tag = this._tags[index];\n            invariant$1(tag, \"old rule at index `\" + index + \"` not found\");\n            tag.textContent = rule;\n        }\n        return index;\n    };\n    _proto.deleteRule = function deleteRule(index) {\n        if (typeof window === \"undefined\") {\n            this._serverSheet.deleteRule(index);\n            return;\n        }\n        if (this._optimizeForSpeed) {\n            this.replaceRule(index, \"\");\n        } else {\n            var tag = this._tags[index];\n            invariant$1(tag, \"rule at index `\" + index + \"` not found\");\n            tag.parentNode.removeChild(tag);\n            this._tags[index] = null;\n        }\n    };\n    _proto.flush = function flush() {\n        this._injected = false;\n        this._rulesCount = 0;\n        if (typeof window !== \"undefined\") {\n            this._tags.forEach(function(tag) {\n                return tag && tag.parentNode.removeChild(tag);\n            });\n            this._tags = [];\n        } else {\n            // simpler on server\n            this._serverSheet.cssRules = [];\n        }\n    };\n    _proto.cssRules = function cssRules() {\n        var _this = this;\n        if (typeof window === \"undefined\") {\n            return this._serverSheet.cssRules;\n        }\n        return this._tags.reduce(function(rules, tag) {\n            if (tag) {\n                rules = rules.concat(Array.prototype.map.call(_this.getSheetForTag(tag).cssRules, function(rule) {\n                    return rule.cssText === _this._deletedRulePlaceholder ? null : rule;\n                }));\n            } else {\n                rules.push(null);\n            }\n            return rules;\n        }, []);\n    };\n    _proto.makeStyleTag = function makeStyleTag(name, cssString, relativeToTag) {\n        if (cssString) {\n            invariant$1(isString(cssString), \"makeStyleTag accepts only strings as second parameter\");\n        }\n        var tag = document.createElement(\"style\");\n        if (this._nonce) tag.setAttribute(\"nonce\", this._nonce);\n        tag.type = \"text/css\";\n        tag.setAttribute(\"data-\" + name, \"\");\n        if (cssString) {\n            tag.appendChild(document.createTextNode(cssString));\n        }\n        var head = document.head || document.getElementsByTagName(\"head\")[0];\n        if (relativeToTag) {\n            head.insertBefore(tag, relativeToTag);\n        } else {\n            head.appendChild(tag);\n        }\n        return tag;\n    };\n    _createClass(StyleSheet, [\n        {\n            key: \"length\",\n            get: function get() {\n                return this._rulesCount;\n            }\n        }\n    ]);\n    return StyleSheet;\n}();\nfunction invariant$1(condition, message) {\n    if (!condition) {\n        throw new Error(\"StyleSheet: \" + message + \".\");\n    }\n}\nfunction hash(str) {\n    var _$hash = 5381, i = str.length;\n    while(i){\n        _$hash = _$hash * 33 ^ str.charCodeAt(--i);\n    }\n    /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */ return _$hash >>> 0;\n}\nvar stringHash = hash;\nvar sanitize = function(rule) {\n    return rule.replace(/\\/style/gi, \"\\\\/style\");\n};\nvar cache = {};\n/**\n * computeId\n *\n * Compute and memoize a jsx id from a basedId and optionally props.\n */ function computeId(baseId, props) {\n    if (!props) {\n        return \"jsx-\" + baseId;\n    }\n    var propsToString = String(props);\n    var key = baseId + propsToString;\n    if (!cache[key]) {\n        cache[key] = \"jsx-\" + stringHash(baseId + \"-\" + propsToString);\n    }\n    return cache[key];\n}\n/**\n * computeSelector\n *\n * Compute and memoize dynamic selectors.\n */ function computeSelector(id, css) {\n    var selectoPlaceholderRegexp = /__jsx-style-dynamic-selector/g;\n    // Sanitize SSR-ed CSS.\n    // Client side code doesn't need to be sanitized since we use\n    // document.createTextNode (dev) and the CSSOM api sheet.insertRule (prod).\n    if (typeof window === \"undefined\") {\n        css = sanitize(css);\n    }\n    var idcss = id + css;\n    if (!cache[idcss]) {\n        cache[idcss] = css.replace(selectoPlaceholderRegexp, id);\n    }\n    return cache[idcss];\n}\nfunction mapRulesToStyle(cssRules, options) {\n    if (options === void 0) options = {};\n    return cssRules.map(function(args) {\n        var id = args[0];\n        var css = args[1];\n        return /*#__PURE__*/ React__default[\"default\"].createElement(\"style\", {\n            id: \"__\" + id,\n            // Avoid warnings upon render with a key\n            key: \"__\" + id,\n            nonce: options.nonce ? options.nonce : undefined,\n            dangerouslySetInnerHTML: {\n                __html: css\n            }\n        });\n    });\n}\nvar StyleSheetRegistry = /*#__PURE__*/ function() {\n    function StyleSheetRegistry(param) {\n        var ref = param === void 0 ? {} : param, _styleSheet = ref.styleSheet, styleSheet = _styleSheet === void 0 ? null : _styleSheet, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? false : _optimizeForSpeed;\n        this._sheet = styleSheet || new StyleSheet({\n            name: \"styled-jsx\",\n            optimizeForSpeed: optimizeForSpeed\n        });\n        this._sheet.inject();\n        if (styleSheet && typeof optimizeForSpeed === \"boolean\") {\n            this._sheet.setOptimizeForSpeed(optimizeForSpeed);\n            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();\n        }\n        this._fromServer = undefined;\n        this._indices = {};\n        this._instancesCounts = {};\n    }\n    var _proto = StyleSheetRegistry.prototype;\n    _proto.add = function add(props) {\n        var _this = this;\n        if (undefined === this._optimizeForSpeed) {\n            this._optimizeForSpeed = Array.isArray(props.children);\n            this._sheet.setOptimizeForSpeed(this._optimizeForSpeed);\n            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();\n        }\n        if (typeof window !== \"undefined\" && !this._fromServer) {\n            this._fromServer = this.selectFromServer();\n            this._instancesCounts = Object.keys(this._fromServer).reduce(function(acc, tagName) {\n                acc[tagName] = 0;\n                return acc;\n            }, {});\n        }\n        var ref = this.getIdAndRules(props), styleId = ref.styleId, rules = ref.rules;\n        // Deduping: just increase the instances count.\n        if (styleId in this._instancesCounts) {\n            this._instancesCounts[styleId] += 1;\n            return;\n        }\n        var indices = rules.map(function(rule) {\n            return _this._sheet.insertRule(rule);\n        }) // Filter out invalid rules\n        .filter(function(index) {\n            return index !== -1;\n        });\n        this._indices[styleId] = indices;\n        this._instancesCounts[styleId] = 1;\n    };\n    _proto.remove = function remove(props) {\n        var _this = this;\n        var styleId = this.getIdAndRules(props).styleId;\n        invariant(styleId in this._instancesCounts, \"styleId: `\" + styleId + \"` not found\");\n        this._instancesCounts[styleId] -= 1;\n        if (this._instancesCounts[styleId] < 1) {\n            var tagFromServer = this._fromServer && this._fromServer[styleId];\n            if (tagFromServer) {\n                tagFromServer.parentNode.removeChild(tagFromServer);\n                delete this._fromServer[styleId];\n            } else {\n                this._indices[styleId].forEach(function(index) {\n                    return _this._sheet.deleteRule(index);\n                });\n                delete this._indices[styleId];\n            }\n            delete this._instancesCounts[styleId];\n        }\n    };\n    _proto.update = function update(props, nextProps) {\n        this.add(nextProps);\n        this.remove(props);\n    };\n    _proto.flush = function flush() {\n        this._sheet.flush();\n        this._sheet.inject();\n        this._fromServer = undefined;\n        this._indices = {};\n        this._instancesCounts = {};\n    };\n    _proto.cssRules = function cssRules() {\n        var _this = this;\n        var fromServer = this._fromServer ? Object.keys(this._fromServer).map(function(styleId) {\n            return [\n                styleId,\n                _this._fromServer[styleId]\n            ];\n        }) : [];\n        var cssRules = this._sheet.cssRules();\n        return fromServer.concat(Object.keys(this._indices).map(function(styleId) {\n            return [\n                styleId,\n                _this._indices[styleId].map(function(index) {\n                    return cssRules[index].cssText;\n                }).join(_this._optimizeForSpeed ? \"\" : \"\\n\")\n            ];\n        }) // filter out empty rules\n        .filter(function(rule) {\n            return Boolean(rule[1]);\n        }));\n    };\n    _proto.styles = function styles(options) {\n        return mapRulesToStyle(this.cssRules(), options);\n    };\n    _proto.getIdAndRules = function getIdAndRules(props) {\n        var css = props.children, dynamic = props.dynamic, id = props.id;\n        if (dynamic) {\n            var styleId = computeId(id, dynamic);\n            return {\n                styleId: styleId,\n                rules: Array.isArray(css) ? css.map(function(rule) {\n                    return computeSelector(styleId, rule);\n                }) : [\n                    computeSelector(styleId, css)\n                ]\n            };\n        }\n        return {\n            styleId: computeId(id),\n            rules: Array.isArray(css) ? css : [\n                css\n            ]\n        };\n    };\n    /**\n   * selectFromServer\n   *\n   * Collects style tags from the document with id __jsx-XXX\n   */ _proto.selectFromServer = function selectFromServer() {\n        var elements = Array.prototype.slice.call(document.querySelectorAll('[id^=\"__jsx-\"]'));\n        return elements.reduce(function(acc, element) {\n            var id = element.id.slice(2);\n            acc[id] = element;\n            return acc;\n        }, {});\n    };\n    return StyleSheetRegistry;\n}();\nfunction invariant(condition, message) {\n    if (!condition) {\n        throw new Error(\"StyleSheetRegistry: \" + message + \".\");\n    }\n}\nvar StyleSheetContext = /*#__PURE__*/ React.createContext(null);\nStyleSheetContext.displayName = \"StyleSheetContext\";\nfunction createStyleRegistry() {\n    return new StyleSheetRegistry();\n}\nfunction StyleRegistry(param) {\n    _s();\n    var configuredRegistry = param.registry, children = param.children;\n    var rootRegistry = React.useContext(StyleSheetContext);\n    var ref = React.useState(function() {\n        return rootRegistry || configuredRegistry || createStyleRegistry();\n    }), registry = ref[0];\n    return /*#__PURE__*/ React__default[\"default\"].createElement(StyleSheetContext.Provider, {\n        value: registry\n    }, children);\n}\n_s(StyleRegistry, \"vgRS4YV7PcSMQCYHzGaNuBIBcZQ=\");\n_c1 = StyleRegistry;\nfunction useStyleRegistry() {\n    _s1();\n    return React.useContext(StyleSheetContext);\n}\n_s1(useStyleRegistry, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n// Opt-into the new `useInsertionEffect` API in React 18, fallback to `useLayoutEffect`.\n// https://github.com/reactwg/react-18/discussions/110\nvar useInsertionEffect = React__default[\"default\"].useInsertionEffect || React__default[\"default\"].useLayoutEffect;\nvar defaultRegistry = typeof window !== \"undefined\" ? createStyleRegistry() : undefined;\nfunction JSXStyle(props) {\n    _s2();\n    var registry = defaultRegistry ? defaultRegistry : useStyleRegistry();\n    // If `registry` does not exist, we do nothing here.\n    if (!registry) {\n        return null;\n    }\n    if (typeof window === \"undefined\") {\n        registry.add(props);\n        return null;\n    }\n    useInsertionEffect(function() {\n        registry.add(props);\n        return function() {\n            registry.remove(props);\n        };\n    // props.children can be string[], will be striped since id is identical\n    }, [\n        props.id,\n        String(props.dynamic)\n    ]);\n    return null;\n}\n_s2(JSXStyle, \"48Sqj1BUqkshsPdz6NEWXDn8pF4=\", false, function() {\n    return [\n        useStyleRegistry,\n        useInsertionEffect\n    ];\n});\n_c2 = JSXStyle;\nJSXStyle.dynamic = function(info) {\n    return info.map(function(tagInfo) {\n        var baseId = tagInfo[0];\n        var props = tagInfo[1];\n        return computeId(baseId, props);\n    }).join(\" \");\n};\nexports.StyleRegistry = StyleRegistry;\nexports.createStyleRegistry = createStyleRegistry;\nexports.style = JSXStyle;\nexports.useStyleRegistry = useStyleRegistry;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"React__default\");\n$RefreshReg$(_c1, \"StyleRegistry\");\n$RefreshReg$(_c2, \"JSXStyle\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L2Rpc3QvaW5kZXgvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUFBLG1CQUFPQSxDQUFDO0FBQ1IsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFFcEIsU0FBU0Usc0JBQXVCQyxDQUFDO0lBQUksT0FBT0EsS0FBSyxPQUFPQSxNQUFNLFlBQVksYUFBYUEsSUFBSUEsSUFBSTtRQUFFLFdBQVdBO0lBQUU7QUFBRztBQUVqSCxJQUFJQyxpQkFBaUIsV0FBVyxHQUFFRixzQkFBc0JEOztBQUV4RDs7O0FBR0EsR0FBRyxTQUFTSSxrQkFBa0JDLE1BQU0sRUFBRUMsS0FBSztJQUN2QyxJQUFJLElBQUlDLElBQUksR0FBR0EsSUFBSUQsTUFBTUUsTUFBTSxFQUFFRCxJQUFJO1FBQ2pDLElBQUlFLGFBQWFILEtBQUssQ0FBQ0MsRUFBRTtRQUN6QkUsV0FBV0MsVUFBVSxHQUFHRCxXQUFXQyxVQUFVLElBQUk7UUFDakRELFdBQVdFLFlBQVksR0FBRztRQUMxQixJQUFJLFdBQVdGLFlBQVlBLFdBQVdHLFFBQVEsR0FBRztRQUNqREMsT0FBT0MsY0FBYyxDQUFDVCxRQUFRSSxXQUFXTSxHQUFHLEVBQUVOO0lBQ2xEO0FBQ0o7QUFDQSxTQUFTTyxhQUFhQyxXQUFXLEVBQUVDLFVBQVUsRUFBRUMsV0FBVztJQUN0RCxJQUFJRCxZQUFZZCxrQkFBa0JhLFlBQVlHLFNBQVMsRUFBRUY7SUFDekQsSUFBSUMsYUFBYWYsa0JBQWtCYSxhQUFhRTtJQUNoRCxPQUFPRjtBQUNYO0FBQ0EsSUFBSUksU0FBUyxPQUFPQyxPQUFPQSxLQUFLLGVBQWVBLE9BQU9BLENBQUNDLEdBQUcsSUFBSUQsa0JBQXlCO0FBQ3ZGLElBQUlFLFdBQVcsU0FBU0MsQ0FBQztJQUNyQixPQUFPWixPQUFPTyxTQUFTLENBQUNNLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDRixPQUFPO0FBQ2pEO0FBQ0EsSUFBSUcsYUFBYSxXQUFXLEdB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R0FBRyxDQUFDMUg7UUFDYixPQUFPO1lBQ0h5SixTQUFTcEIsTUFBTSxDQUFDckk7UUFDcEI7SUFDSix3RUFBd0U7SUFDeEUsR0FBRztRQUNDQSxNQUFNeUcsRUFBRTtRQUNSRixPQUFPdkcsTUFBTThJLE9BQU87S0FDdkI7SUFDRCxPQUFPO0FBQ1g7SUFyQlNxQjs7UUFDOENKO1FBU25EQzs7O01BVktHO0FBc0JUQSxTQUFTckIsT0FBTyxHQUFHLFNBQVNzQixJQUFJO0lBQzVCLE9BQU9BLEtBQUt2RixHQUFHLENBQUMsU0FBU3dGLE9BQU87UUFDNUIsSUFBSWhFLFNBQVNnRSxPQUFPLENBQUMsRUFBRTtRQUN2QixJQUFJckssUUFBUXFLLE9BQU8sQ0FBQyxFQUFFO1FBQ3RCLE9BQU9qRSxVQUFVQyxRQUFRckc7SUFDN0IsR0FBRzJJLElBQUksQ0FBQztBQUNaO0FBRUEyQixxQkFBcUIsR0FBR2Y7QUFDeEJlLDJCQUEyQixHQUFHaEI7QUFDOUJnQixhQUFhLEdBQUdIO0FBQ2hCRyx3QkFBd0IsR0FBR1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0eWxlZC1qc3gvZGlzdC9pbmRleC9pbmRleC5qcz9iMDA1Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJ2NsaWVudC1vbmx5Jyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIFJlYWN0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeShSZWFjdCk7XG5cbi8qXG5CYXNlZCBvbiBHbGFtb3IncyBzaGVldFxuaHR0cHM6Ly9naXRodWIuY29tL3RocmVlcG9pbnRvbmUvZ2xhbW9yL2Jsb2IvNjY3YjQ4MGQzMWIzNzIxYTkwNTAyMWIyNmUxMjkwY2U5MmNhMjg3OS9zcmMvc2hlZXQuanNcbiovIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxudmFyIGlzUHJvZCA9IHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSBcIltvYmplY3QgU3RyaW5nXVwiO1xufTtcbnZhciBTdHlsZVNoZWV0ID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTdHlsZVNoZWV0KHBhcmFtKSB7XG4gICAgICAgIHZhciByZWYgPSBwYXJhbSA9PT0gdm9pZCAwID8ge30gOiBwYXJhbSwgX25hbWUgPSByZWYubmFtZSwgbmFtZSA9IF9uYW1lID09PSB2b2lkIDAgPyBcInN0eWxlc2hlZXRcIiA6IF9uYW1lLCBfb3B0aW1pemVGb3JTcGVlZCA9IHJlZi5vcHRpbWl6ZUZvclNwZWVkLCBvcHRpbWl6ZUZvclNwZWVkID0gX29wdGltaXplRm9yU3BlZWQgPT09IHZvaWQgMCA/IGlzUHJvZCA6IF9vcHRpbWl6ZUZvclNwZWVkO1xuICAgICAgICBpbnZhcmlhbnQkMShpc1N0cmluZyhuYW1lKSwgXCJgbmFtZWAgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX2RlbGV0ZWRSdWxlUGxhY2Vob2xkZXIgPSBcIiNcIiArIG5hbWUgKyBcIi1kZWxldGVkLXJ1bGVfX19fe31cIjtcbiAgICAgICAgaW52YXJpYW50JDEodHlwZW9mIG9wdGltaXplRm9yU3BlZWQgPT09IFwiYm9vbGVhblwiLCBcImBvcHRpbWl6ZUZvclNwZWVkYCBtdXN0IGJlIGEgYm9vbGVhblwiKTtcbiAgICAgICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9IG9wdGltaXplRm9yU3BlZWQ7XG4gICAgICAgIHRoaXMuX3NlcnZlclNoZWV0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl90YWdzID0gW107XG4gICAgICAgIHRoaXMuX2luamVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3J1bGVzQ291bnQgPSAwO1xuICAgICAgICB2YXIgbm9kZSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtwcm9wZXJ0eT1cImNzcC1ub25jZVwiXScpO1xuICAgICAgICB0aGlzLl9ub25jZSA9IG5vZGUgPyBub2RlLmdldEF0dHJpYnV0ZShcImNvbnRlbnRcIikgOiBudWxsO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gU3R5bGVTaGVldC5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnNldE9wdGltaXplRm9yU3BlZWQgPSBmdW5jdGlvbiBzZXRPcHRpbWl6ZUZvclNwZWVkKGJvb2wpIHtcbiAgICAgICAgaW52YXJpYW50JDEodHlwZW9mIGJvb2wgPT09IFwiYm9vbGVhblwiLCBcImBzZXRPcHRpbWl6ZUZvclNwZWVkYCBhY2NlcHRzIGEgYm9vbGVhblwiKTtcbiAgICAgICAgaW52YXJpYW50JDEodGhpcy5fcnVsZXNDb3VudCA9PT0gMCwgXCJvcHRpbWl6ZUZvclNwZWVkIGNhbm5vdCBiZSB3aGVuIHJ1bGVzIGhhdmUgYWxyZWFkeSBiZWVuIGluc2VydGVkXCIpO1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIHRoaXMuX29wdGltaXplRm9yU3BlZWQgPSBib29sO1xuICAgICAgICB0aGlzLmluamVjdCgpO1xuICAgIH07XG4gICAgX3Byb3RvLmlzT3B0aW1pemVGb3JTcGVlZCA9IGZ1bmN0aW9uIGlzT3B0aW1pemVGb3JTcGVlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGltaXplRm9yU3BlZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uaW5qZWN0ID0gZnVuY3Rpb24gaW5qZWN0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpbnZhcmlhbnQkMSghdGhpcy5faW5qZWN0ZWQsIFwic2hlZXQgYWxyZWFkeSBpbmplY3RlZFwiKTtcbiAgICAgICAgdGhpcy5faW5qZWN0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkKSB7XG4gICAgICAgICAgICB0aGlzLl90YWdzWzBdID0gdGhpcy5tYWtlU3R5bGVUYWcodGhpcy5fbmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gXCJpbnNlcnRSdWxlXCIgaW4gdGhpcy5nZXRTaGVldCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9vcHRpbWl6ZUZvclNwZWVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Byb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU3R5bGVTaGVldDogb3B0aW1pemVGb3JTcGVlZCBtb2RlIG5vdCBzdXBwb3J0ZWQgZmFsbGluZyBiYWNrIHRvIHN0YW5kYXJkIG1vZGUuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5qZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlcnZlclNoZWV0ID0ge1xuICAgICAgICAgICAgY3NzUnVsZXM6IFtdLFxuICAgICAgICAgICAgaW5zZXJ0UnVsZTogZnVuY3Rpb24ocnVsZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlc1tpbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NUZXh0OiBydWxlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NlcnZlclNoZWV0LmNzc1J1bGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgY3NzVGV4dDogcnVsZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlbGV0ZVJ1bGU6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3NlcnZlclNoZWV0LmNzc1J1bGVzW2luZGV4XSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0U2hlZXRGb3JUYWcgPSBmdW5jdGlvbiBnZXRTaGVldEZvclRhZyh0YWcpIHtcbiAgICAgICAgaWYgKHRhZy5zaGVldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhZy5zaGVldDtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIHdlaXJkbmVzcyBicm91Z2h0IHRvIHlvdSBieSBmaXJlZm94XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkb2N1bWVudC5zdHlsZVNoZWV0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuc3R5bGVTaGVldHNbaV0ub3duZXJOb2RlID09PSB0YWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuc3R5bGVTaGVldHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5nZXRTaGVldCA9IGZ1bmN0aW9uIGdldFNoZWV0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTaGVldEZvclRhZyh0aGlzLl90YWdzW3RoaXMuX3RhZ3MubGVuZ3RoIC0gMV0pO1xuICAgIH07XG4gICAgX3Byb3RvLmluc2VydFJ1bGUgPSBmdW5jdGlvbiBpbnNlcnRSdWxlKHJ1bGUsIGluZGV4KSB7XG4gICAgICAgIGludmFyaWFudCQxKGlzU3RyaW5nKHJ1bGUpLCBcImBpbnNlcnRSdWxlYCBhY2NlcHRzIG9ubHkgc3RyaW5nc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMuX3NlcnZlclNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NlcnZlclNoZWV0Lmluc2VydFJ1bGUocnVsZSwgaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3J1bGVzQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICAgICAgdmFyIHNoZWV0ID0gdGhpcy5nZXRTaGVldCgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2hlZXQuY3NzUnVsZXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcyB3ZWlyZG5lc3MgZm9yIHBlcmYsIGFuZCBjaHJvbWUncyB3ZWlyZCBidWdcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwMDA3OTkyL2Nocm9tZS1zdWRkZW5seS1zdG9wcGVkLWFjY2VwdGluZy1pbnNlcnRydWxlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNoZWV0Lmluc2VydFJ1bGUocnVsZSwgaW5kZXgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUHJvZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJTdHlsZVNoZWV0OiBpbGxlZ2FsIHJ1bGU6IFxcblxcblwiICsgcnVsZSArIFwiXFxuXFxuU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8yMDAwNzk5MiBmb3IgbW9yZSBpbmZvXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW5zZXJ0aW9uUG9pbnQgPSB0aGlzLl90YWdzW2luZGV4XTtcbiAgICAgICAgICAgIHRoaXMuX3RhZ3MucHVzaCh0aGlzLm1ha2VTdHlsZVRhZyh0aGlzLl9uYW1lLCBydWxlLCBpbnNlcnRpb25Qb2ludCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ydWxlc0NvdW50Kys7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVwbGFjZVJ1bGUgPSBmdW5jdGlvbiByZXBsYWNlUnVsZShpbmRleCwgcnVsZSkge1xuICAgICAgICBpZiAodGhpcy5fb3B0aW1pemVGb3JTcGVlZCB8fCB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB2YXIgc2hlZXQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gdGhpcy5nZXRTaGVldCgpIDogdGhpcy5fc2VydmVyU2hlZXQ7XG4gICAgICAgICAgICBpZiAoIXJ1bGUudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgcnVsZSA9IHRoaXMuX2RlbGV0ZWRSdWxlUGxhY2Vob2xkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNoZWV0LmNzc1J1bGVzW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIC8vIEBUQkQgU2hvdWxkIHdlIHRocm93IGFuIGVycm9yP1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzaGVldC5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Byb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU3R5bGVTaGVldDogaWxsZWdhbCBydWxlOiBcXG5cXG5cIiArIHJ1bGUgKyBcIlxcblxcblNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMjAwMDc5OTIgZm9yIG1vcmUgaW5mb1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSW4gb3JkZXIgdG8gcHJlc2VydmUgdGhlIGluZGljZXMgd2UgaW5zZXJ0IGEgZGVsZXRlUnVsZVBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZSh0aGlzLl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gdGhpcy5fdGFnc1tpbmRleF07XG4gICAgICAgICAgICBpbnZhcmlhbnQkMSh0YWcsIFwib2xkIHJ1bGUgYXQgaW5kZXggYFwiICsgaW5kZXggKyBcImAgbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgdGFnLnRleHRDb250ZW50ID0gcnVsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVsZXRlUnVsZSA9IGZ1bmN0aW9uIGRlbGV0ZVJ1bGUoaW5kZXgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlcnZlclNoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vcHRpbWl6ZUZvclNwZWVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VSdWxlKGluZGV4LCBcIlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YWcgPSB0aGlzLl90YWdzW2luZGV4XTtcbiAgICAgICAgICAgIGludmFyaWFudCQxKHRhZywgXCJydWxlIGF0IGluZGV4IGBcIiArIGluZGV4ICsgXCJgIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIHRhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhZyk7XG4gICAgICAgICAgICB0aGlzLl90YWdzW2luZGV4XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICB0aGlzLl9pbmplY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ydWxlc0NvdW50ID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhZ3MuZm9yRWFjaChmdW5jdGlvbih0YWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnICYmIHRhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3RhZ3MgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNpbXBsZXIgb24gc2VydmVyXG4gICAgICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlcyA9IFtdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY3NzUnVsZXMgPSBmdW5jdGlvbiBjc3NSdWxlcygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGFncy5yZWR1Y2UoZnVuY3Rpb24ocnVsZXMsIHRhZykge1xuICAgICAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgICAgIHJ1bGVzID0gcnVsZXMuY29uY2F0KEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChfdGhpcy5nZXRTaGVldEZvclRhZyh0YWcpLmNzc1J1bGVzLCBmdW5jdGlvbihydWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydWxlLmNzc1RleHQgPT09IF90aGlzLl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyID8gbnVsbCA6IHJ1bGU7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBydWxlcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVzO1xuICAgICAgICB9LCBbXSk7XG4gICAgfTtcbiAgICBfcHJvdG8ubWFrZVN0eWxlVGFnID0gZnVuY3Rpb24gbWFrZVN0eWxlVGFnKG5hbWUsIGNzc1N0cmluZywgcmVsYXRpdmVUb1RhZykge1xuICAgICAgICBpZiAoY3NzU3RyaW5nKSB7XG4gICAgICAgICAgICBpbnZhcmlhbnQkMShpc1N0cmluZyhjc3NTdHJpbmcpLCBcIm1ha2VTdHlsZVRhZyBhY2NlcHRzIG9ubHkgc3RyaW5ncyBhcyBzZWNvbmQgcGFyYW1ldGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgIGlmICh0aGlzLl9ub25jZSkgdGFnLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIHRoaXMuX25vbmNlKTtcbiAgICAgICAgdGFnLnR5cGUgPSBcInRleHQvY3NzXCI7XG4gICAgICAgIHRhZy5zZXRBdHRyaWJ1dGUoXCJkYXRhLVwiICsgbmFtZSwgXCJcIik7XG4gICAgICAgIGlmIChjc3NTdHJpbmcpIHtcbiAgICAgICAgICAgIHRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3NTdHJpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xuICAgICAgICBpZiAocmVsYXRpdmVUb1RhZykge1xuICAgICAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUodGFnLCByZWxhdGl2ZVRvVGFnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQodGFnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH07XG4gICAgX2NyZWF0ZUNsYXNzKFN0eWxlU2hlZXQsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImxlbmd0aFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3J1bGVzQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gU3R5bGVTaGVldDtcbn0oKTtcbmZ1bmN0aW9uIGludmFyaWFudCQxKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0eWxlU2hlZXQ6IFwiICsgbWVzc2FnZSArIFwiLlwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gICAgdmFyIF8kaGFzaCA9IDUzODEsIGkgPSBzdHIubGVuZ3RoO1xuICAgIHdoaWxlKGkpe1xuICAgICAgICBfJGhhc2ggPSBfJGhhc2ggKiAzMyBeIHN0ci5jaGFyQ29kZUF0KC0taSk7XG4gICAgfVxuICAgIC8qIEphdmFTY3JpcHQgZG9lcyBiaXR3aXNlIG9wZXJhdGlvbnMgKGxpa2UgWE9SLCBhYm92ZSkgb24gMzItYml0IHNpZ25lZFxuICAgKiBpbnRlZ2Vycy4gU2luY2Ugd2Ugd2FudCB0aGUgcmVzdWx0cyB0byBiZSBhbHdheXMgcG9zaXRpdmUsIGNvbnZlcnQgdGhlXG4gICAqIHNpZ25lZCBpbnQgdG8gYW4gdW5zaWduZWQgYnkgZG9pbmcgYW4gdW5zaWduZWQgYml0c2hpZnQuICovIHJldHVybiBfJGhhc2ggPj4+IDA7XG59XG52YXIgc3RyaW5nSGFzaCA9IGhhc2g7XG5cbnZhciBzYW5pdGl6ZSA9IGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICByZXR1cm4gcnVsZS5yZXBsYWNlKC9cXC9zdHlsZS9naSwgXCJcXFxcL3N0eWxlXCIpO1xufTtcbnZhciBjYWNoZSA9IHt9O1xuLyoqXG4gKiBjb21wdXRlSWRcbiAqXG4gKiBDb21wdXRlIGFuZCBtZW1vaXplIGEganN4IGlkIGZyb20gYSBiYXNlZElkIGFuZCBvcHRpb25hbGx5IHByb3BzLlxuICovIGZ1bmN0aW9uIGNvbXB1dGVJZChiYXNlSWQsIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcykge1xuICAgICAgICByZXR1cm4gXCJqc3gtXCIgKyBiYXNlSWQ7XG4gICAgfVxuICAgIHZhciBwcm9wc1RvU3RyaW5nID0gU3RyaW5nKHByb3BzKTtcbiAgICB2YXIga2V5ID0gYmFzZUlkICsgcHJvcHNUb1N0cmluZztcbiAgICBpZiAoIWNhY2hlW2tleV0pIHtcbiAgICAgICAgY2FjaGVba2V5XSA9IFwianN4LVwiICsgc3RyaW5nSGFzaChiYXNlSWQgKyBcIi1cIiArIHByb3BzVG9TdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVba2V5XTtcbn1cbi8qKlxuICogY29tcHV0ZVNlbGVjdG9yXG4gKlxuICogQ29tcHV0ZSBhbmQgbWVtb2l6ZSBkeW5hbWljIHNlbGVjdG9ycy5cbiAqLyBmdW5jdGlvbiBjb21wdXRlU2VsZWN0b3IoaWQsIGNzcykge1xuICAgIHZhciBzZWxlY3RvUGxhY2Vob2xkZXJSZWdleHAgPSAvX19qc3gtc3R5bGUtZHluYW1pYy1zZWxlY3Rvci9nO1xuICAgIC8vIFNhbml0aXplIFNTUi1lZCBDU1MuXG4gICAgLy8gQ2xpZW50IHNpZGUgY29kZSBkb2Vzbid0IG5lZWQgdG8gYmUgc2FuaXRpemVkIHNpbmNlIHdlIHVzZVxuICAgIC8vIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlIChkZXYpIGFuZCB0aGUgQ1NTT00gYXBpIHNoZWV0Lmluc2VydFJ1bGUgKHByb2QpLlxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNzcyA9IHNhbml0aXplKGNzcyk7XG4gICAgfVxuICAgIHZhciBpZGNzcyA9IGlkICsgY3NzO1xuICAgIGlmICghY2FjaGVbaWRjc3NdKSB7XG4gICAgICAgIGNhY2hlW2lkY3NzXSA9IGNzcy5yZXBsYWNlKHNlbGVjdG9QbGFjZWhvbGRlclJlZ2V4cCwgaWQpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbaWRjc3NdO1xufVxuXG5mdW5jdGlvbiBtYXBSdWxlc1RvU3R5bGUoY3NzUnVsZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgcmV0dXJuIGNzc1J1bGVzLm1hcChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBpZCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBjc3MgPSBhcmdzWzFdO1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInN0eWxlXCIsIHtcbiAgICAgICAgICAgIGlkOiBcIl9fXCIgKyBpZCxcbiAgICAgICAgICAgIC8vIEF2b2lkIHdhcm5pbmdzIHVwb24gcmVuZGVyIHdpdGggYSBrZXlcbiAgICAgICAgICAgIGtleTogXCJfX1wiICsgaWQsXG4gICAgICAgICAgICBub25jZTogb3B0aW9ucy5ub25jZSA/IG9wdGlvbnMubm9uY2UgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICAgICAgICAgIF9faHRtbDogY3NzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxudmFyIFN0eWxlU2hlZXRSZWdpc3RyeSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVTaGVldFJlZ2lzdHJ5KHBhcmFtKSB7XG4gICAgICAgIHZhciByZWYgPSBwYXJhbSA9PT0gdm9pZCAwID8ge30gOiBwYXJhbSwgX3N0eWxlU2hlZXQgPSByZWYuc3R5bGVTaGVldCwgc3R5bGVTaGVldCA9IF9zdHlsZVNoZWV0ID09PSB2b2lkIDAgPyBudWxsIDogX3N0eWxlU2hlZXQsIF9vcHRpbWl6ZUZvclNwZWVkID0gcmVmLm9wdGltaXplRm9yU3BlZWQsIG9wdGltaXplRm9yU3BlZWQgPSBfb3B0aW1pemVGb3JTcGVlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW1pemVGb3JTcGVlZDtcbiAgICAgICAgdGhpcy5fc2hlZXQgPSBzdHlsZVNoZWV0IHx8IG5ldyBTdHlsZVNoZWV0KHtcbiAgICAgICAgICAgIG5hbWU6IFwic3R5bGVkLWpzeFwiLFxuICAgICAgICAgICAgb3B0aW1pemVGb3JTcGVlZDogb3B0aW1pemVGb3JTcGVlZFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2hlZXQuaW5qZWN0KCk7XG4gICAgICAgIGlmIChzdHlsZVNoZWV0ICYmIHR5cGVvZiBvcHRpbWl6ZUZvclNwZWVkID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhpcy5fc2hlZXQuc2V0T3B0aW1pemVGb3JTcGVlZChvcHRpbWl6ZUZvclNwZWVkKTtcbiAgICAgICAgICAgIHRoaXMuX29wdGltaXplRm9yU3BlZWQgPSB0aGlzLl9zaGVldC5pc09wdGltaXplRm9yU3BlZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mcm9tU2VydmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9pbmRpY2VzID0ge307XG4gICAgICAgIHRoaXMuX2luc3RhbmNlc0NvdW50cyA9IHt9O1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gU3R5bGVTaGVldFJlZ2lzdHJ5LnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IHRoaXMuX29wdGltaXplRm9yU3BlZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX29wdGltaXplRm9yU3BlZWQgPSBBcnJheS5pc0FycmF5KHByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIHRoaXMuX3NoZWV0LnNldE9wdGltaXplRm9yU3BlZWQodGhpcy5fb3B0aW1pemVGb3JTcGVlZCk7XG4gICAgICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gdGhpcy5fc2hlZXQuaXNPcHRpbWl6ZUZvclNwZWVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgIXRoaXMuX2Zyb21TZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Zyb21TZXJ2ZXIgPSB0aGlzLnNlbGVjdEZyb21TZXJ2ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlc0NvdW50cyA9IE9iamVjdC5rZXlzKHRoaXMuX2Zyb21TZXJ2ZXIpLnJlZHVjZShmdW5jdGlvbihhY2MsIHRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICBhY2NbdGFnTmFtZV0gPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZiA9IHRoaXMuZ2V0SWRBbmRSdWxlcyhwcm9wcyksIHN0eWxlSWQgPSByZWYuc3R5bGVJZCwgcnVsZXMgPSByZWYucnVsZXM7XG4gICAgICAgIC8vIERlZHVwaW5nOiBqdXN0IGluY3JlYXNlIHRoZSBpbnN0YW5jZXMgY291bnQuXG4gICAgICAgIGlmIChzdHlsZUlkIGluIHRoaXMuX2luc3RhbmNlc0NvdW50cykge1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VzQ291bnRzW3N0eWxlSWRdICs9IDE7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGljZXMgPSBydWxlcy5tYXAoZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9zaGVldC5pbnNlcnRSdWxlKHJ1bGUpO1xuICAgICAgICB9KS8vIEZpbHRlciBvdXQgaW52YWxpZCBydWxlc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXggIT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faW5kaWNlc1tzdHlsZUlkXSA9IGluZGljZXM7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXSA9IDE7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBzdHlsZUlkID0gdGhpcy5nZXRJZEFuZFJ1bGVzKHByb3BzKS5zdHlsZUlkO1xuICAgICAgICBpbnZhcmlhbnQoc3R5bGVJZCBpbiB0aGlzLl9pbnN0YW5jZXNDb3VudHMsIFwic3R5bGVJZDogYFwiICsgc3R5bGVJZCArIFwiYCBub3QgZm91bmRcIik7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXSAtPSAxO1xuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2VzQ291bnRzW3N0eWxlSWRdIDwgMSkge1xuICAgICAgICAgICAgdmFyIHRhZ0Zyb21TZXJ2ZXIgPSB0aGlzLl9mcm9tU2VydmVyICYmIHRoaXMuX2Zyb21TZXJ2ZXJbc3R5bGVJZF07XG4gICAgICAgICAgICBpZiAodGFnRnJvbVNlcnZlcikge1xuICAgICAgICAgICAgICAgIHRhZ0Zyb21TZXJ2ZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YWdGcm9tU2VydmVyKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZnJvbVNlcnZlcltzdHlsZUlkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5kaWNlc1tzdHlsZUlkXS5mb3JFYWNoKGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fc2hlZXQuZGVsZXRlUnVsZShpbmRleCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2luZGljZXNbc3R5bGVJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faW5zdGFuY2VzQ291bnRzW3N0eWxlSWRdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHByb3BzLCBuZXh0UHJvcHMpIHtcbiAgICAgICAgdGhpcy5hZGQobmV4dFByb3BzKTtcbiAgICAgICAgdGhpcy5yZW1vdmUocHJvcHMpO1xuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoID0gZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgICAgIHRoaXMuX3NoZWV0LmZsdXNoKCk7XG4gICAgICAgIHRoaXMuX3NoZWV0LmluamVjdCgpO1xuICAgICAgICB0aGlzLl9mcm9tU2VydmVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9pbmRpY2VzID0ge307XG4gICAgICAgIHRoaXMuX2luc3RhbmNlc0NvdW50cyA9IHt9O1xuICAgIH07XG4gICAgX3Byb3RvLmNzc1J1bGVzID0gZnVuY3Rpb24gY3NzUnVsZXMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmcm9tU2VydmVyID0gdGhpcy5fZnJvbVNlcnZlciA/IE9iamVjdC5rZXlzKHRoaXMuX2Zyb21TZXJ2ZXIpLm1hcChmdW5jdGlvbihzdHlsZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgX3RoaXMuX2Zyb21TZXJ2ZXJbc3R5bGVJZF1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pIDogW107XG4gICAgICAgIHZhciBjc3NSdWxlcyA9IHRoaXMuX3NoZWV0LmNzc1J1bGVzKCk7XG4gICAgICAgIHJldHVybiBmcm9tU2VydmVyLmNvbmNhdChPYmplY3Qua2V5cyh0aGlzLl9pbmRpY2VzKS5tYXAoZnVuY3Rpb24oc3R5bGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgICAgIF90aGlzLl9pbmRpY2VzW3N0eWxlSWRdLm1hcChmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3NzUnVsZXNbaW5kZXhdLmNzc1RleHQ7XG4gICAgICAgICAgICAgICAgfSkuam9pbihfdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA/IFwiXCIgOiBcIlxcblwiKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSkvLyBmaWx0ZXIgb3V0IGVtcHR5IHJ1bGVzXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4ocnVsZVsxXSk7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIF9wcm90by5zdHlsZXMgPSBmdW5jdGlvbiBzdHlsZXMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbWFwUnVsZXNUb1N0eWxlKHRoaXMuY3NzUnVsZXMoKSwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0SWRBbmRSdWxlcyA9IGZ1bmN0aW9uIGdldElkQW5kUnVsZXMocHJvcHMpIHtcbiAgICAgICAgdmFyIGNzcyA9IHByb3BzLmNoaWxkcmVuLCBkeW5hbWljID0gcHJvcHMuZHluYW1pYywgaWQgPSBwcm9wcy5pZDtcbiAgICAgICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZUlkID0gY29tcHV0ZUlkKGlkLCBkeW5hbWljKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3R5bGVJZDogc3R5bGVJZCxcbiAgICAgICAgICAgICAgICBydWxlczogQXJyYXkuaXNBcnJheShjc3MpID8gY3NzLm1hcChmdW5jdGlvbihydWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wdXRlU2VsZWN0b3Ioc3R5bGVJZCwgcnVsZSk7XG4gICAgICAgICAgICAgICAgfSkgOiBbXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVTZWxlY3RvcihzdHlsZUlkLCBjc3MpXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3R5bGVJZDogY29tcHV0ZUlkKGlkKSxcbiAgICAgICAgICAgIHJ1bGVzOiBBcnJheS5pc0FycmF5KGNzcykgPyBjc3MgOiBbXG4gICAgICAgICAgICAgICAgY3NzXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICogc2VsZWN0RnJvbVNlcnZlclxuICAgKlxuICAgKiBDb2xsZWN0cyBzdHlsZSB0YWdzIGZyb20gdGhlIGRvY3VtZW50IHdpdGggaWQgX19qc3gtWFhYXG4gICAqLyBfcHJvdG8uc2VsZWN0RnJvbVNlcnZlciA9IGZ1bmN0aW9uIHNlbGVjdEZyb21TZXJ2ZXIoKSB7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZF49XCJfX2pzeC1cIl0nKSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBlbGVtZW50LmlkLnNsaWNlKDIpO1xuICAgICAgICAgICAgYWNjW2lkXSA9IGVsZW1lbnQ7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3R5bGVTaGVldFJlZ2lzdHJ5O1xufSgpO1xuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0eWxlU2hlZXRSZWdpc3RyeTogXCIgKyBtZXNzYWdlICsgXCIuXCIpO1xuICAgIH1cbn1cbnZhciBTdHlsZVNoZWV0Q29udGV4dCA9IC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblN0eWxlU2hlZXRDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJTdHlsZVNoZWV0Q29udGV4dFwiO1xuZnVuY3Rpb24gY3JlYXRlU3R5bGVSZWdpc3RyeSgpIHtcbiAgICByZXR1cm4gbmV3IFN0eWxlU2hlZXRSZWdpc3RyeSgpO1xufVxuZnVuY3Rpb24gU3R5bGVSZWdpc3RyeShwYXJhbSkge1xuICAgIHZhciBjb25maWd1cmVkUmVnaXN0cnkgPSBwYXJhbS5yZWdpc3RyeSwgY2hpbGRyZW4gPSBwYXJhbS5jaGlsZHJlbjtcbiAgICB2YXIgcm9vdFJlZ2lzdHJ5ID0gUmVhY3QudXNlQ29udGV4dChTdHlsZVNoZWV0Q29udGV4dCk7XG4gICAgdmFyIHJlZiA9IFJlYWN0LnVzZVN0YXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcm9vdFJlZ2lzdHJ5IHx8IGNvbmZpZ3VyZWRSZWdpc3RyeSB8fCBjcmVhdGVTdHlsZVJlZ2lzdHJ5KCk7XG4gICAgfSksIHJlZ2lzdHJ5ID0gcmVmWzBdO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFN0eWxlU2hlZXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiByZWdpc3RyeVxuICAgIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIHVzZVN0eWxlUmVnaXN0cnkoKSB7XG4gICAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoU3R5bGVTaGVldENvbnRleHQpO1xufVxuXG4vLyBPcHQtaW50byB0aGUgbmV3IGB1c2VJbnNlcnRpb25FZmZlY3RgIEFQSSBpbiBSZWFjdCAxOCwgZmFsbGJhY2sgdG8gYHVzZUxheW91dEVmZmVjdGAuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vcmVhY3R3Zy9yZWFjdC0xOC9kaXNjdXNzaW9ucy8xMTBcbnZhciB1c2VJbnNlcnRpb25FZmZlY3QgPSBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0udXNlSW5zZXJ0aW9uRWZmZWN0IHx8IFJlYWN0X19kZWZhdWx0W1wiZGVmYXVsdFwiXS51c2VMYXlvdXRFZmZlY3Q7XG52YXIgZGVmYXVsdFJlZ2lzdHJ5ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IGNyZWF0ZVN0eWxlUmVnaXN0cnkoKSA6IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIEpTWFN0eWxlKHByb3BzKSB7XG4gICAgdmFyIHJlZ2lzdHJ5ID0gZGVmYXVsdFJlZ2lzdHJ5ID8gZGVmYXVsdFJlZ2lzdHJ5IDogdXNlU3R5bGVSZWdpc3RyeSgpO1xuICAgIC8vIElmIGByZWdpc3RyeWAgZG9lcyBub3QgZXhpc3QsIHdlIGRvIG5vdGhpbmcgaGVyZS5cbiAgICBpZiAoIXJlZ2lzdHJ5KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZWdpc3RyeS5hZGQocHJvcHMpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0KGZ1bmN0aW9uKCkge1xuICAgICAgICByZWdpc3RyeS5hZGQocHJvcHMpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZWdpc3RyeS5yZW1vdmUocHJvcHMpO1xuICAgICAgICB9O1xuICAgIC8vIHByb3BzLmNoaWxkcmVuIGNhbiBiZSBzdHJpbmdbXSwgd2lsbCBiZSBzdHJpcGVkIHNpbmNlIGlkIGlzIGlkZW50aWNhbFxuICAgIH0sIFtcbiAgICAgICAgcHJvcHMuaWQsXG4gICAgICAgIFN0cmluZyhwcm9wcy5keW5hbWljKVxuICAgIF0pO1xuICAgIHJldHVybiBudWxsO1xufVxuSlNYU3R5bGUuZHluYW1pYyA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgICByZXR1cm4gaW5mby5tYXAoZnVuY3Rpb24odGFnSW5mbykge1xuICAgICAgICB2YXIgYmFzZUlkID0gdGFnSW5mb1swXTtcbiAgICAgICAgdmFyIHByb3BzID0gdGFnSW5mb1sxXTtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVJZChiYXNlSWQsIHByb3BzKTtcbiAgICB9KS5qb2luKFwiIFwiKTtcbn07XG5cbmV4cG9ydHMuU3R5bGVSZWdpc3RyeSA9IFN0eWxlUmVnaXN0cnk7XG5leHBvcnRzLmNyZWF0ZVN0eWxlUmVnaXN0cnkgPSBjcmVhdGVTdHlsZVJlZ2lzdHJ5O1xuZXhwb3J0cy5zdHlsZSA9IEpTWFN0eWxlO1xuZXhwb3J0cy51c2VTdHlsZVJlZ2lzdHJ5ID0gdXNlU3R5bGVSZWdpc3RyeTtcbiJdLCJuYW1lcyI6WyJyZXF1aXJlIiwiUmVhY3QiLCJfaW50ZXJvcERlZmF1bHRMZWdhY3kiLCJlIiwiUmVhY3RfX2RlZmF1bHQiLCJfZGVmaW5lUHJvcGVydGllcyIsInRhcmdldCIsInByb3BzIiwiaSIsImxlbmd0aCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImtleSIsIl9jcmVhdGVDbGFzcyIsIkNvbnN0cnVjdG9yIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwicHJvdG90eXBlIiwiaXNQcm9kIiwicHJvY2VzcyIsImVudiIsImlzU3RyaW5nIiwibyIsInRvU3RyaW5nIiwiY2FsbCIsIlN0eWxlU2hlZXQiLCJwYXJhbSIsInJlZiIsIl9uYW1lIiwibmFtZSIsIl9vcHRpbWl6ZUZvclNwZWVkIiwib3B0aW1pemVGb3JTcGVlZCIsImludmFyaWFudCQxIiwiX2RlbGV0ZWRSdWxlUGxhY2Vob2xkZXIiLCJfc2VydmVyU2hlZXQiLCJ1bmRlZmluZWQiLCJfdGFncyIsIl9pbmplY3RlZCIsIl9ydWxlc0NvdW50Iiwibm9kZSIsIndpbmRvdyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsIl9ub25jZSIsImdldEF0dHJpYnV0ZSIsIl9wcm90byIsInNldE9wdGltaXplRm9yU3BlZWQiLCJib29sIiwiZmx1c2giLCJpbmplY3QiLCJpc09wdGltaXplRm9yU3BlZWQiLCJfdGhpcyIsIm1ha2VTdHlsZVRhZyIsImdldFNoZWV0IiwiY29uc29sZSIsIndhcm4iLCJjc3NSdWxlcyIsImluc2VydFJ1bGUiLCJydWxlIiwiaW5kZXgiLCJjc3NUZXh0IiwicHVzaCIsImRlbGV0ZVJ1bGUiLCJnZXRTaGVldEZvclRhZyIsInRhZyIsInNoZWV0Iiwic3R5bGVTaGVldHMiLCJvd25lck5vZGUiLCJlcnJvciIsImluc2VydGlvblBvaW50IiwicmVwbGFjZVJ1bGUiLCJ0cmltIiwidGV4dENvbnRlbnQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJmb3JFYWNoIiwicmVkdWNlIiwicnVsZXMiLCJjb25jYXQiLCJBcnJheSIsIm1hcCIsImNzc1N0cmluZyIsInJlbGF0aXZlVG9UYWciLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwidHlwZSIsImFwcGVuZENoaWxkIiwiY3JlYXRlVGV4dE5vZGUiLCJoZWFkIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpbnNlcnRCZWZvcmUiLCJnZXQiLCJjb25kaXRpb24iLCJtZXNzYWdlIiwiRXJyb3IiLCJoYXNoIiwic3RyIiwiXyRoYXNoIiwiY2hhckNvZGVBdCIsInN0cmluZ0hhc2giLCJzYW5pdGl6ZSIsInJlcGxhY2UiLCJjYWNoZSIsImNvbXB1dGVJZCIsImJhc2VJZCIsInByb3BzVG9TdHJpbmciLCJTdHJpbmciLCJjb21wdXRlU2VsZWN0b3IiLCJpZCIsImNzcyIsInNlbGVjdG9QbGFjZWhvbGRlclJlZ2V4cCIsImlkY3NzIiwibWFwUnVsZXNUb1N0eWxlIiwib3B0aW9ucyIsImFyZ3MiLCJub25jZSIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIiwiU3R5bGVTaGVldFJlZ2lzdHJ5IiwiX3N0eWxlU2hlZXQiLCJzdHlsZVNoZWV0IiwiX3NoZWV0IiwiX2Zyb21TZXJ2ZXIiLCJfaW5kaWNlcyIsIl9pbnN0YW5jZXNDb3VudHMiLCJhZGQiLCJpc0FycmF5IiwiY2hpbGRyZW4iLCJzZWxlY3RGcm9tU2VydmVyIiwia2V5cyIsImFjYyIsInRhZ05hbWUiLCJnZXRJZEFuZFJ1bGVzIiwic3R5bGVJZCIsImluZGljZXMiLCJmaWx0ZXIiLCJyZW1vdmUiLCJpbnZhcmlhbnQiLCJ0YWdGcm9tU2VydmVyIiwidXBkYXRlIiwibmV4dFByb3BzIiwiZnJvbVNlcnZlciIsImpvaW4iLCJCb29sZWFuIiwic3R5bGVzIiwiZHluYW1pYyIsImVsZW1lbnRzIiwic2xpY2UiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZWxlbWVudCIsIlN0eWxlU2hlZXRDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImRpc3BsYXlOYW1lIiwiY3JlYXRlU3R5bGVSZWdpc3RyeSIsIlN0eWxlUmVnaXN0cnkiLCJjb25maWd1cmVkUmVnaXN0cnkiLCJyZWdpc3RyeSIsInJvb3RSZWdpc3RyeSIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsIlByb3ZpZGVyIiwidmFsdWUiLCJ1c2VTdHlsZVJlZ2lzdHJ5IiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwiZGVmYXVsdFJlZ2lzdHJ5IiwiSlNYU3R5bGUiLCJpbmZvIiwidGFnSW5mbyIsImV4cG9ydHMiLCJzdHlsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/styled-jsx/dist/index/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/styled-jsx/style.js":
/*!******************************************!*\
  !*** ./node_modules/styled-jsx/style.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nmodule.exports = __webpack_require__(/*! ./dist/index */ \"(app-pages-browser)/./node_modules/styled-jsx/dist/index/index.js\").style;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L3N0eWxlLmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsbUlBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L3N0eWxlLmpzPzM3MGIiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvaW5kZXgnKS5zdHlsZVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwic3R5bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/styled-jsx/style.js\n"));

/***/ })

});