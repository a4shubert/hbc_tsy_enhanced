"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/hbc/HbcAgTable.tsx":
/*!***************************************!*\
  !*** ./components/hbc/HbcAgTable.tsx ***!
  \***************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HbcAgTable: function() { return /* binding */ HbcAgTable; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var ag_grid_community_styles_ag_grid_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ag-grid-community/styles/ag-grid.css */ \"(app-pages-browser)/./node_modules/ag-grid-community/styles/ag-grid.css\");\n/* harmony import */ var ag_grid_community_styles_ag_theme_quartz_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ag-grid-community/styles/ag-theme-quartz.css */ \"(app-pages-browser)/./node_modules/ag-grid-community/styles/ag-theme-quartz.css\");\n/* harmony import */ var ag_grid_community__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ag-grid-community */ \"(app-pages-browser)/./node_modules/ag-grid-community/dist/package/main.esm.mjs\");\n/* harmony import */ var ag_grid_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ag-grid-react */ \"(app-pages-browser)/./node_modules/ag-grid-react/dist/package/index.esm.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_4__);\n// HbcAgTable.tsx\n/* __next_internal_client_entry_do_not_use__ HbcAgTable auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\nlet agGridRegistered = false;\nif (!agGridRegistered) {\n    ag_grid_community__WEBPACK_IMPORTED_MODULE_5__.ModuleRegistry.registerModules([\n        ag_grid_community__WEBPACK_IMPORTED_MODULE_5__.AllCommunityModule\n    ]);\n    agGridRegistered = true;\n}\nfunction HbcAgTable(param) {\n    let { rowData, columnDefs, className, height = \"100%\", loading, error, gridOptions, rowIdField, onGridReady, onFilterChanged, onSortChanged, onSelectionChanged, onCellClicked, onCellDoubleClicked, onCellKeyDown, onFilterPaste } = param;\n    _s();\n    const gridApiRef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useRef)(null);\n    const columnFilterTypeByColId = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>{\n        const map = new Map();\n        for (const def of columnDefs !== null && columnDefs !== void 0 ? columnDefs : []){\n            var _def_colId;\n            const colId = (_def_colId = def.colId) !== null && _def_colId !== void 0 ? _def_colId : def.field;\n            if (!colId) continue;\n            map.set(colId, def.filter);\n        }\n        return map;\n    }, [\n        columnDefs\n    ]);\n    async function copyText(text) {\n        try {\n            var _navigator_clipboard, _navigator;\n            if ((_navigator = navigator) === null || _navigator === void 0 ? void 0 : (_navigator_clipboard = _navigator.clipboard) === null || _navigator_clipboard === void 0 ? void 0 : _navigator_clipboard.writeText) {\n                await navigator.clipboard.writeText(text);\n                return;\n            }\n        } catch (e) {\n        // ignore and fall back\n        }\n        const el = document.createElement(\"textarea\");\n        el.value = text;\n        el.setAttribute(\"readonly\", \"true\");\n        el.style.position = \"fixed\";\n        el.style.top = \"-9999px\";\n        document.body.appendChild(el);\n        el.select();\n        document.execCommand(\"copy\");\n        document.body.removeChild(el);\n    }\n    function handleCellKeyDown(e) {\n        var _ev_key;\n        onCellKeyDown === null || onCellKeyDown === void 0 ? void 0 : onCellKeyDown(e);\n        const ev = e.event;\n        if (!ev) return;\n        const key = (_ev_key = ev.key) === null || _ev_key === void 0 ? void 0 : _ev_key.toLowerCase();\n        const isCopy = (ev.metaKey || ev.ctrlKey) && key === \"c\" && !ev.shiftKey && !ev.altKey;\n        if (!isCopy) return;\n        const value = e.value;\n        if (value === null || value === undefined) return;\n        const text = typeof value === \"string\" ? value : String(value);\n        ev.preventDefault();\n        void copyText(text);\n    }\n    function findFloatingFilterColumnId(target) {\n        var _target_closest;\n        if (!target || !(target instanceof HTMLElement)) return null;\n        const direct = (_target_closest = target.closest(\"[col-id]\")) === null || _target_closest === void 0 ? void 0 : _target_closest.getAttribute(\"col-id\");\n        if (direct && direct.length) return direct;\n        const floating = target.closest(\".ag-floating-filter\");\n        if (!floating) return null;\n        const headerCell = target.closest(\".ag-header-cell\");\n        const colId = headerCell === null || headerCell === void 0 ? void 0 : headerCell.getAttribute(\"col-id\");\n        return colId && colId.length ? colId : null;\n    }\n    function setEqualsForTextFilter(colId, filterText) {\n        var _api_onFilterChanged;\n        const api = gridApiRef.current;\n        if (!api) return;\n        var _api_getFilterModel;\n        const model = (_api_getFilterModel = api.getFilterModel()) !== null && _api_getFilterModel !== void 0 ? _api_getFilterModel : {};\n        const existing = model[colId];\n        const nextText = typeof filterText === \"string\" ? filterText : existing === null || existing === void 0 ? void 0 : existing.filter;\n        if (typeof nextText !== \"string\") return;\n        const trimmed = nextText.trim();\n        if (!trimmed) return;\n        if ((existing === null || existing === void 0 ? void 0 : existing.type) && String(existing.type).toLowerCase() === \"equals\") return;\n        var _existing_filterType;\n        api.setFilterModel({\n            ...model,\n            [colId]: {\n                ...existing !== null && existing !== void 0 ? existing : {},\n                filterType: (_existing_filterType = existing === null || existing === void 0 ? void 0 : existing.filterType) !== null && _existing_filterType !== void 0 ? _existing_filterType : \"text\",\n                type: \"equals\",\n                filter: trimmed\n            }\n        });\n        (_api_onFilterChanged = api.onFilterChanged) === null || _api_onFilterChanged === void 0 ? void 0 : _api_onFilterChanged.call(api);\n    }\n    function parseDateFromText(input) {\n        const text = input.trim();\n        if (!text) return null;\n        const isoMatch = /^(\\d{4}-\\d{2}-\\d{2})/.exec(text);\n        if (isoMatch) return isoMatch[1];\n        const ms = Date.parse(text);\n        if (!Number.isFinite(ms)) return null;\n        const d = new Date(ms);\n        const yyyy = String(d.getFullYear()).padStart(4, \"0\");\n        const mm = String(d.getMonth() + 1).padStart(2, \"0\");\n        const dd = String(d.getDate()).padStart(2, \"0\");\n        return \"\".concat(yyyy, \"-\").concat(mm, \"-\").concat(dd);\n    }\n    function setEqualsForDateFilter(colId, filterText) {\n        var _api_onFilterChanged;\n        const api = gridApiRef.current;\n        if (!api) return;\n        var _api_getFilterModel;\n        const model = (_api_getFilterModel = api.getFilterModel()) !== null && _api_getFilterModel !== void 0 ? _api_getFilterModel : {};\n        const existing = model[colId];\n        const nextText = typeof filterText === \"string\" ? filterText : existing === null || existing === void 0 ? void 0 : existing.dateFrom;\n        if (typeof nextText !== \"string\") return;\n        const dateFrom = parseDateFromText(nextText);\n        if (!dateFrom) return;\n        if ((existing === null || existing === void 0 ? void 0 : existing.type) && String(existing.type).toLowerCase() === \"equals\" && (existing === null || existing === void 0 ? void 0 : existing.dateFrom)) return;\n        api.setFilterModel({\n            ...model,\n            [colId]: {\n                ...existing !== null && existing !== void 0 ? existing : {},\n                filterType: \"date\",\n                type: \"equals\",\n                dateFrom\n            }\n        });\n        (_api_onFilterChanged = api.onFilterChanged) === null || _api_onFilterChanged === void 0 ? void 0 : _api_onFilterChanged.call(api);\n    }\n    function getPreferredFilterType(colId) {\n        const api = gridApiRef.current;\n        var _api_getFilterModel;\n        const model = (_api_getFilterModel = api === null || api === void 0 ? void 0 : api.getFilterModel()) !== null && _api_getFilterModel !== void 0 ? _api_getFilterModel : {};\n        const existing = model[colId];\n        const existingFilterType = typeof (existing === null || existing === void 0 ? void 0 : existing.filterType) === \"string\" ? existing.filterType : undefined;\n        if (existingFilterType) return existingFilterType;\n        const colFilter = columnFilterTypeByColId.get(colId);\n        if (colFilter === \"agDateColumnFilter\") return \"date\";\n        if (colFilter === \"agNumberColumnFilter\") return \"number\";\n        return \"text\";\n    }\n    function handleKeyDownCapture(ev) {\n        var _ev_key;\n        const key = (_ev_key = ev.key) === null || _ev_key === void 0 ? void 0 : _ev_key.toLowerCase();\n        const isCopy = (ev.metaKey || ev.ctrlKey) && key === \"c\" && !ev.shiftKey && !ev.altKey;\n        const isPaste = (ev.metaKey || ev.ctrlKey) && key === \"v\" && !ev.shiftKey && !ev.altKey;\n        if (!isCopy && !isPaste) return;\n        const colId = findFloatingFilterColumnId(ev.target);\n        if (!colId) {\n            if (isCopy) {\n                const text = getFocusedCellText();\n                if (!text) return;\n                ev.preventDefault();\n                void copyText(text);\n            }\n            return;\n        }\n        if (isPaste) {\n            onFilterPaste === null || onFilterPaste === void 0 ? void 0 : onFilterPaste(colId);\n            window.setTimeout(()=>{\n                const el = ev.target;\n                const value = el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement ? el.value : undefined;\n                const filterType = getPreferredFilterType(colId);\n                if (filterType === \"date\") {\n                    setEqualsForDateFilter(colId, value);\n                    return;\n                }\n                setEqualsForTextFilter(colId, value);\n            }, 40);\n            return;\n        }\n        if (isCopy) {\n            const text = getFocusedCellText();\n            if (!text) return;\n            ev.preventDefault();\n            void copyText(text);\n        }\n    }\n    function handlePasteCapture(ev) {\n        const colId = findFloatingFilterColumnId(ev.target);\n        if (!colId) return;\n        onFilterPaste === null || onFilterPaste === void 0 ? void 0 : onFilterPaste(colId);\n        window.setTimeout(()=>{\n            const el = ev.target;\n            const value = el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement ? el.value : undefined;\n            const filterType = getPreferredFilterType(colId);\n            if (filterType === \"date\") {\n                setEqualsForDateFilter(colId, value);\n                return;\n            }\n            setEqualsForTextFilter(colId, value);\n        }, 40);\n    }\n    function getFocusedCellText() {\n        var _api_getFocusedCell, _api_getDisplayedRowAtIndex, _focused_column_getColId, _focused_column, _rowNode_data;\n        const api = gridApiRef.current;\n        if (!api) return null;\n        const focused = (_api_getFocusedCell = api.getFocusedCell) === null || _api_getFocusedCell === void 0 ? void 0 : _api_getFocusedCell.call(api);\n        if (!focused) return null;\n        const rowNode = (_api_getDisplayedRowAtIndex = api.getDisplayedRowAtIndex) === null || _api_getDisplayedRowAtIndex === void 0 ? void 0 : _api_getDisplayedRowAtIndex.call(api, focused.rowIndex);\n        const colId = (_focused_column = focused.column) === null || _focused_column === void 0 ? void 0 : (_focused_column_getColId = _focused_column.getColId) === null || _focused_column_getColId === void 0 ? void 0 : _focused_column_getColId.call(_focused_column);\n        if (!rowNode || !colId) return null;\n        const value = (_rowNode_data = rowNode.data) === null || _rowNode_data === void 0 ? void 0 : _rowNode_data[colId];\n        if (value === null || value === undefined) return null;\n        return typeof value === \"string\" ? value : String(value);\n    }\n    const autoColumnDefs = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>{\n        if (columnDefs && columnDefs.length) return columnDefs;\n        var _rowData_;\n        const keys = Object.keys((_rowData_ = rowData === null || rowData === void 0 ? void 0 : rowData[0]) !== null && _rowData_ !== void 0 ? _rowData_ : {});\n        return keys.map((field)=>({\n                field\n            }));\n    }, [\n        columnDefs,\n        rowData\n    ]);\n    const defaultColDef = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>({\n            resizable: true,\n            sortable: true,\n            unSortIcon: true,\n            filter: true,\n            floatingFilter: true,\n            minWidth: 140\n        }), []);\n    const mergedGridOptions = (0,react__WEBPACK_IMPORTED_MODULE_4__.useMemo)(()=>({\n            theme: \"legacy\",\n            animateRows: true,\n            rowSelection: \"single\",\n            suppressCellFocus: false,\n            pagination: false,\n            alwaysShowHorizontalScroll: true,\n            suppressHorizontalScroll: false,\n            suppressRowClickSelection: true,\n            enableCellTextSelection: true,\n            ensureDomOrder: true,\n            ...gridOptions !== null && gridOptions !== void 0 ? gridOptions : {}\n        }), [\n        gridOptions\n    ]);\n    const finalClassName = [\n        \"hbc-ag-grid ag-theme-quartz-dark w-full rounded-lg border border-[color:var(--color-border)] bg-[color:var(--color-card)]\",\n        className\n    ].filter(Boolean).join(\" \");\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"w-full\",\n        style: {\n            height\n        },\n        onKeyDownCapture: handleKeyDownCapture,\n        onPasteCapture: handlePasteCapture,\n        children: [\n            error ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mb-3 rounded-md border border-red-500/40 bg-red-500/10 px-3 py-2 text-sm text-red-200\",\n                children: error\n            }, void 0, false, {\n                fileName: \"/Users/alexandershubert/git/hbc_tsy_enhanced/hbc_web/components/hbc/HbcAgTable.tsx\",\n                lineNumber: 332,\n                columnNumber: 9\n            }, this) : null,\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: finalClassName,\n                style: {\n                    height: \"100%\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ag_grid_react__WEBPACK_IMPORTED_MODULE_3__.AgGridReact, {\n                    rowData: rowData,\n                    columnDefs: autoColumnDefs,\n                    defaultColDef: defaultColDef,\n                    gridOptions: mergedGridOptions,\n                    loading: loading,\n                    onGridReady: (e)=>{\n                        gridApiRef.current = e.api;\n                        onGridReady === null || onGridReady === void 0 ? void 0 : onGridReady(e);\n                    },\n                    onFilterChanged: onFilterChanged,\n                    onSortChanged: onSortChanged,\n                    onSelectionChanged: onSelectionChanged,\n                    onCellClicked: onCellClicked,\n                    onCellDoubleClicked: onCellDoubleClicked,\n                    onCellKeyDown: handleCellKeyDown,\n                    getRowId: rowIdField ? (p)=>{\n                        var _p_data;\n                        const raw = (_p_data = p.data) === null || _p_data === void 0 ? void 0 : _p_data[rowIdField];\n                        if (typeof raw === \"string\" && raw.length) return raw;\n                        if (typeof raw === \"number\") return String(raw);\n                        return JSON.stringify(p.data);\n                    } : undefined\n                }, void 0, false, {\n                    fileName: \"/Users/alexandershubert/git/hbc_tsy_enhanced/hbc_web/components/hbc/HbcAgTable.tsx\",\n                    lineNumber: 338,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/alexandershubert/git/hbc_tsy_enhanced/hbc_web/components/hbc/HbcAgTable.tsx\",\n                lineNumber: 337,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/alexandershubert/git/hbc_tsy_enhanced/hbc_web/components/hbc/HbcAgTable.tsx\",\n        lineNumber: 325,\n        columnNumber: 5\n    }, this);\n}\n_s(HbcAgTable, \"DrDoD2M1j1XQLsNZvbq+A08+uL0=\");\n_c = HbcAgTable;\nvar _c;\n$RefreshReg$(_c, \"HbcAgTable\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvaGJjL0hiY0FnVGFibGUudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEsaUJBQWlCOzs7QUFHNEI7QUFDUTtBQUVpQjtBQU0zQjtBQUVKO0FBRXZDLElBQUlLLG1CQUFtQjtBQUN2QixJQUFJLENBQUNBLGtCQUFrQjtJQUNyQkosNkRBQWNBLENBQUNLLGVBQWUsQ0FBQztRQUFDTixpRUFBa0JBO0tBQUM7SUFDbkRLLG1CQUFtQjtBQUNyQjtBQXFCTyxTQUFTRSxXQUE4QyxLQWlCekM7UUFqQnlDLEVBQzVEQyxPQUFPLEVBQ1BDLFVBQVUsRUFDVkMsU0FBUyxFQUNUQyxTQUFTLE1BQU0sRUFDZkMsT0FBTyxFQUNQQyxLQUFLLEVBQ0xDLFdBQVcsRUFDWEMsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLGVBQWUsRUFDZkMsYUFBYSxFQUNiQyxrQkFBa0IsRUFDbEJDLGFBQWEsRUFDYkMsbUJBQW1CLEVBQ25CQyxhQUFhLEVBQ2JDLGFBQWEsRUFDTSxHQWpCeUM7O0lBa0I1RCxNQUFNQyxhQUFhcEIsNkNBQU1BLENBQW9CO0lBQzdDLE1BQU1xQiwwQkFBMEJ0Qiw4Q0FBT0EsQ0FBQztRQUN0QyxNQUFNdUIsTUFBTSxJQUFJQztRQUNoQixLQUFLLE1BQU1DLE9BQU9uQix1QkFBQUEsd0JBQUFBLGFBQWMsRUFBRSxDQUFFO2dCQUNuQm1CO1lBQWYsTUFBTUMsUUFBU0QsQ0FBQUEsYUFBQUEsSUFBSUMsS0FBSyxjQUFURCx3QkFBQUEsYUFBYUEsSUFBSUUsS0FBSztZQUNyQyxJQUFJLENBQUNELE9BQU87WUFDWkgsSUFBSUssR0FBRyxDQUFDRixPQUFPRCxJQUFJSSxNQUFNO1FBQzNCO1FBQ0EsT0FBT047SUFDVCxHQUFHO1FBQUNqQjtLQUFXO0lBRWYsZUFBZXdCLFNBQVNDLElBQVk7UUFDbEMsSUFBSTtnQkFDRUMsc0JBQUFBO1lBQUosS0FBSUEsYUFBQUEsdUJBQUFBLGtDQUFBQSx1QkFBQUEsV0FBV0Ms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QUN0RCw0RUFBQ1Qsc0RBQVdBO29CQUNWTSxTQUFTQTtvQkFDVEMsWUFBWXFIO29CQUNaRyxlQUFlQTtvQkFDZm5ILGFBQWF5SDtvQkFDYjNILFNBQVNBO29CQUNUSSxhQUFhLENBQUNvQzt3QkFDWjVCLFdBQVdxRCxPQUFPLEdBQUd6QixFQUFFd0IsR0FBRzt3QkFDMUI1RCx3QkFBQUEsa0NBQUFBLFlBQWNvQztvQkFDaEI7b0JBQ0FuQyxpQkFBaUJBO29CQUNqQkMsZUFBZUE7b0JBQ2ZDLG9CQUFvQkE7b0JBQ3BCQyxlQUFlQTtvQkFDZkMscUJBQXFCQTtvQkFDckJDLGVBQWU2QjtvQkFDZnFHLFVBQ0V6SSxhQUNJLENBQUMwSTs0QkFDYUE7d0JBQVosTUFBTUMsT0FBTUQsVUFBQUEsRUFBRTVCLElBQUksY0FBTjRCLDhCQUFBQSxPQUFRLENBQUMxSSxXQUFXO3dCQUNoQyxJQUFJLE9BQU8ySSxRQUFRLFlBQVlBLElBQUluRixNQUFNLEVBQUUsT0FBT21GO3dCQUNsRCxJQUFJLE9BQU9BLFFBQVEsVUFBVSxPQUFPM0YsT0FBTzJGO3dCQUMzQyxPQUFPQyxLQUFLQyxTQUFTLENBQUNILEVBQUU1QixJQUFJO29CQUM5QixJQUNBL0Q7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTWhCO0dBdFVnQnZEO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvaGJjL0hiY0FnVGFibGUudHN4PzJiZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSGJjQWdUYWJsZS50c3hcblwidXNlIGNsaWVudFwiXG5cbmltcG9ydCBcImFnLWdyaWQtY29tbXVuaXR5L3N0eWxlcy9hZy1ncmlkLmNzc1wiXG5pbXBvcnQgXCJhZy1ncmlkLWNvbW11bml0eS9zdHlsZXMvYWctdGhlbWUtcXVhcnR6LmNzc1wiXG5cbmltcG9ydCB7IEFsbENvbW11bml0eU1vZHVsZSwgTW9kdWxlUmVnaXN0cnkgfSBmcm9tIFwiYWctZ3JpZC1jb21tdW5pdHlcIlxuaW1wb3J0IHR5cGUgeyBDb2xEZWYsIEdyaWRBcGksIEdyaWRPcHRpb25zIH0gZnJvbSBcImFnLWdyaWQtY29tbXVuaXR5XCJcbmltcG9ydCB0eXBlIHsgQ2VsbENsaWNrZWRFdmVudCwgQ2VsbERvdWJsZUNsaWNrZWRFdmVudCB9IGZyb20gXCJhZy1ncmlkLWNvbW11bml0eVwiXG5pbXBvcnQgdHlwZSB7IENlbGxLZXlEb3duRXZlbnQgfSBmcm9tIFwiYWctZ3JpZC1jb21tdW5pdHlcIlxuaW1wb3J0IHR5cGUgeyBGaWx0ZXJDaGFuZ2VkRXZlbnQsIEdyaWRSZWFkeUV2ZW50LCBTb3J0Q2hhbmdlZEV2ZW50IH0gZnJvbSBcImFnLWdyaWQtY29tbXVuaXR5XCJcbmltcG9ydCB0eXBlIHsgU2VsZWN0aW9uQ2hhbmdlZEV2ZW50IH0gZnJvbSBcImFnLWdyaWQtY29tbXVuaXR5XCJcbmltcG9ydCB7IEFnR3JpZFJlYWN0IH0gZnJvbSBcImFnLWdyaWQtcmVhY3RcIlxuaW1wb3J0IHR5cGUgeyBLZXlib2FyZEV2ZW50IGFzIFJlYWN0S2V5Ym9hcmRFdmVudCB9IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgeyB1c2VNZW1vLCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIlxuXG5sZXQgYWdHcmlkUmVnaXN0ZXJlZCA9IGZhbHNlXG5pZiAoIWFnR3JpZFJlZ2lzdGVyZWQpIHtcbiAgTW9kdWxlUmVnaXN0cnkucmVnaXN0ZXJNb2R1bGVzKFtBbGxDb21tdW5pdHlNb2R1bGVdKVxuICBhZ0dyaWRSZWdpc3RlcmVkID0gdHJ1ZVxufVxuXG5leHBvcnQgdHlwZSBIYmNBZ1RhYmxlUHJvcHM8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+PiA9IHtcbiAgcm93RGF0YTogVFtdXG4gIGNvbHVtbkRlZnM/OiBDb2xEZWY8VD5bXVxuICBjbGFzc05hbWU/OiBzdHJpbmdcbiAgaGVpZ2h0PzogbnVtYmVyIHwgc3RyaW5nXG4gIGxvYWRpbmc/OiBib29sZWFuXG4gIGVycm9yPzogc3RyaW5nIHwgbnVsbFxuICBncmlkT3B0aW9ucz86IEdyaWRPcHRpb25zPFQ+XG4gIHJvd0lkRmllbGQ/OiBFeHRyYWN0PGtleW9mIFQsIHN0cmluZz5cbiAgb25HcmlkUmVhZHk/OiAoZXZlbnQ6IEdyaWRSZWFkeUV2ZW50PFQ+KSA9PiB2b2lkXG4gIG9uRmlsdGVyQ2hhbmdlZD86IChldmVudDogRmlsdGVyQ2hhbmdlZEV2ZW50PFQ+KSA9PiB2b2lkXG4gIG9uU29ydENoYW5nZWQ/OiAoZXZlbnQ6IFNvcnRDaGFuZ2VkRXZlbnQ8VD4pID0+IHZvaWRcbiAgb25TZWxlY3Rpb25DaGFuZ2VkPzogKGV2ZW50OiBTZWxlY3Rpb25DaGFuZ2VkRXZlbnQ8VD4pID0+IHZvaWRcbiAgb25DZWxsQ2xpY2tlZD86IChldmVudDogQ2VsbENsaWNrZWRFdmVudDxUPikgPT4gdm9pZFxuICBvbkNlbGxEb3VibGVDbGlja2VkPzogKGV2ZW50OiBDZWxsRG91YmxlQ2xpY2tlZEV2ZW50PFQ+KSA9PiB2b2lkXG4gIG9uQ2VsbEtleURvd24/OiAoZXZlbnQ6IENlbGxLZXlEb3duRXZlbnQ8VD4pID0+IHZvaWRcbiAgb25GaWx0ZXJQYXN0ZT86IChjb2xJZDogc3RyaW5nKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBIYmNBZ1RhYmxlPFQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oe1xuICByb3dEYXRhLFxuICBjb2x1bW5EZWZzLFxuICBjbGFzc05hbWUsXG4gIGhlaWdodCA9IFwiMTAwJVwiLFxuICBsb2FkaW5nLFxuICBlcnJvcixcbiAgZ3JpZE9wdGlvbnMsXG4gIHJvd0lkRmllbGQsXG4gIG9uR3JpZFJlYWR5LFxuICBvbkZpbHRlckNoYW5nZWQsXG4gIG9uU29ydENoYW5nZWQsXG4gIG9uU2VsZWN0aW9uQ2hhbmdlZCxcbiAgb25DZWxsQ2xpY2tlZCxcbiAgb25DZWxsRG91YmxlQ2xpY2tlZCxcbiAgb25DZWxsS2V5RG93bixcbiAgb25GaWx0ZXJQYXN0ZSxcbn06IEhiY0FnVGFibGVQcm9wczxUPikge1xuICBjb25zdCBncmlkQXBpUmVmID0gdXNlUmVmPEdyaWRBcGk8VD4gfCBudWxsPihudWxsKVxuICBjb25zdCBjb2x1bW5GaWx0ZXJUeXBlQnlDb2xJZCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXA8c3RyaW5nLCB1bmtub3duPigpXG4gICAgZm9yIChjb25zdCBkZWYgb2YgY29sdW1uRGVmcyA/PyBbXSkge1xuICAgICAgY29uc3QgY29sSWQgPSAoZGVmLmNvbElkID8/IGRlZi5maWVsZCkgYXMgc3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgICBpZiAoIWNvbElkKSBjb250aW51ZVxuICAgICAgbWFwLnNldChjb2xJZCwgZGVmLmZpbHRlcilcbiAgICB9XG4gICAgcmV0dXJuIG1hcFxuICB9LCBbY29sdW1uRGVmc10pXG5cbiAgYXN5bmMgZnVuY3Rpb24gY29weVRleHQodGV4dDogc3RyaW5nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChuYXZpZ2F0b3I/LmNsaXBib2FyZD8ud3JpdGVUZXh0KSB7XG4gICAgICAgIGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gaWdub3JlIGFuZCBmYWxsIGJhY2tcbiAgICB9XG5cbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKVxuICAgIGVsLnZhbHVlID0gdGV4dFxuICAgIGVsLnNldEF0dHJpYnV0ZShcInJlYWRvbmx5XCIsIFwidHJ1ZVwiKVxuICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiXG4gICAgZWwuc3R5bGUudG9wID0gXCItOTk5OXB4XCJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKVxuICAgIGVsLnNlbGVjdCgpXG4gICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJjb3B5XCIpXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbClcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNlbGxLZXlEb3duKGU6IENlbGxLZXlEb3duRXZlbnQ8VD4pIHtcbiAgICBvbkNlbGxLZXlEb3duPy4oZSlcblxuICAgIGNvbnN0IGV2ID0gZS5ldmVudCBhcyBLZXlib2FyZEV2ZW50IHwgdW5kZWZpbmVkXG4gICAgaWYgKCFldikgcmV0dXJuXG5cbiAgICBjb25zdCBrZXkgPSBldi5rZXk/LnRvTG93ZXJDYXNlKClcbiAgICBjb25zdCBpc0NvcHkgPSAoZXYubWV0YUtleSB8fCBldi5jdHJsS2V5KSAmJiBrZXkgPT09IFwiY1wiICYmICFldi5zaGlmdEtleSAmJiAhZXYuYWx0S2V5XG4gICAgaWYgKCFpc0NvcHkpIHJldHVyblxuXG4gICAgY29uc3QgdmFsdWUgPSBlLnZhbHVlXG4gICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVyblxuICAgIGNvbnN0IHRleHQgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IFN0cmluZyh2YWx1ZSlcblxuICAgIGV2LnByZXZlbnREZWZhdWx0KClcbiAgICB2b2lkIGNvcHlUZXh0KHRleHQpXG4gIH1cblxuICBmdW5jdGlvbiBmaW5kRmxvYXRpbmdGaWx0ZXJDb2x1bW5JZCh0YXJnZXQ6IEV2ZW50VGFyZ2V0IHwgbnVsbCk6IHN0cmluZyB8IG51bGwge1xuICAgIGlmICghdGFyZ2V0IHx8ICEodGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSByZXR1cm4gbnVsbFxuICAgIGNvbnN0IGRpcmVjdCA9IHRhcmdldC5jbG9zZXN0KFwiW2NvbC1pZF1cIik/LmdldEF0dHJpYnV0ZShcImNvbC1pZFwiKVxuICAgIGlmIChkaXJlY3QgJiYgZGlyZWN0Lmxlbmd0aCkgcmV0dXJuIGRpcmVjdFxuXG4gICAgY29uc3QgZmxvYXRpbmcgPSB0YXJnZXQuY2xvc2VzdChcIi5hZy1mbG9hdGluZy1maWx0ZXJcIilcbiAgICBpZiAoIWZsb2F0aW5nKSByZXR1cm4gbnVsbFxuXG4gICAgY29uc3QgaGVhZGVyQ2VsbCA9IHRhcmdldC5jbG9zZXN0KFwiLmFnLWhlYWRlci1jZWxsXCIpXG4gICAgY29uc3QgY29sSWQgPSBoZWFkZXJDZWxsPy5nZXRBdHRyaWJ1dGUoXCJjb2wtaWRcIilcbiAgICByZXR1cm4gY29sSWQgJiYgY29sSWQubGVuZ3RoID8gY29sSWQgOiBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBzZXRFcXVhbHNGb3JUZXh0RmlsdGVyKGNvbElkOiBzdHJpbmcsIGZpbHRlclRleHQ/OiBzdHJpbmcpIHtcbiAgICBjb25zdCBhcGkgPSBncmlkQXBpUmVmLmN1cnJlbnRcbiAgICBpZiAoIWFwaSkgcmV0dXJuXG5cbiAgICBjb25zdCBtb2RlbCA9IChhcGkuZ2V0RmlsdGVyTW9kZWwoKSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+KSA/PyB7fVxuICAgIGNvbnN0IGV4aXN0aW5nID0gbW9kZWxbY29sSWRdXG4gICAgY29uc3QgbmV4dFRleHQgPSB0eXBlb2YgZmlsdGVyVGV4dCA9PT0gXCJzdHJpbmdcIiA/IGZpbHRlclRleHQgOiBleGlzdGluZz8uZmlsdGVyXG4gICAgaWYgKHR5cGVvZiBuZXh0VGV4dCAhPT0gXCJzdHJpbmdcIikgcmV0dXJuXG4gICAgY29uc3QgdHJpbW1lZCA9IG5leHRUZXh0LnRyaW0oKVxuICAgIGlmICghdHJpbW1lZCkgcmV0dXJuXG5cbiAgICBpZiAoZXhpc3Rpbmc/LnR5cGUgJiYgU3RyaW5nKGV4aXN0aW5nLnR5cGUpLnRvTG93ZXJDYXNlKCkgPT09IFwiZXF1YWxzXCIpIHJldHVyblxuXG4gICAgYXBpLnNldEZpbHRlck1vZGVsKHtcbiAgICAgIC4uLm1vZGVsLFxuICAgICAgW2NvbElkXToge1xuICAgICAgICAuLi4oZXhpc3RpbmcgPz8ge30pLFxuICAgICAgICBmaWx0ZXJUeXBlOiAoZXhpc3Rpbmc/LmZpbHRlclR5cGUgYXMgc3RyaW5nIHwgdW5kZWZpbmVkKSA/PyBcInRleHRcIixcbiAgICAgICAgdHlwZTogXCJlcXVhbHNcIixcbiAgICAgICAgZmlsdGVyOiB0cmltbWVkLFxuICAgICAgfSxcbiAgICB9KVxuICAgIGFwaS5vbkZpbHRlckNoYW5nZWQ/LigpXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZURhdGVGcm9tVGV4dChpbnB1dDogc3RyaW5nKSB7XG4gICAgY29uc3QgdGV4dCA9IGlucHV0LnRyaW0oKVxuICAgIGlmICghdGV4dCkgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IGlzb01hdGNoID0gL14oXFxkezR9LVxcZHsyfS1cXGR7Mn0pLy5leGVjKHRleHQpXG4gICAgaWYgKGlzb01hdGNoKSByZXR1cm4gaXNvTWF0Y2hbMV1cblxuICAgIGNvbnN0IG1zID0gRGF0ZS5wYXJzZSh0ZXh0KVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG1zKSkgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShtcylcbiAgICBjb25zdCB5eXl5ID0gU3RyaW5nKGQuZ2V0RnVsbFllYXIoKSkucGFkU3RhcnQoNCwgXCIwXCIpXG4gICAgY29uc3QgbW0gPSBTdHJpbmcoZC5nZXRNb250aCgpICsgMSkucGFkU3RhcnQoMiwgXCIwXCIpXG4gICAgY29uc3QgZGQgPSBTdHJpbmcoZC5nZXREYXRlKCkpLnBhZFN0YXJ0KDIsIFwiMFwiKVxuICAgIHJldHVybiBgJHt5eXl5fS0ke21tfS0ke2RkfWBcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEVxdWFsc0ZvckRhdGVGaWx0ZXIoY29sSWQ6IHN0cmluZywgZmlsdGVyVGV4dD86IHN0cmluZykge1xuICAgIGNvbnN0IGFwaSA9IGdyaWRBcGlSZWYuY3VycmVudFxuICAgIGlmICghYXBpKSByZXR1cm5cblxuICAgIGNvbnN0IG1vZGVsID0gKGFwaS5nZXRGaWx0ZXJNb2RlbCgpIGFzIFJlY29yZDxzdHJpbmcsIGFueT4pID8/IHt9XG4gICAgY29uc3QgZXhpc3RpbmcgPSBtb2RlbFtjb2xJZF1cblxuICAgIGNvbnN0IG5leHRUZXh0ID0gdHlwZW9mIGZpbHRlclRleHQgPT09IFwic3RyaW5nXCIgPyBmaWx0ZXJUZXh0IDogZXhpc3Rpbmc/LmRhdGVGcm9tXG4gICAgaWYgKHR5cGVvZiBuZXh0VGV4dCAhPT0gXCJzdHJpbmdcIikgcmV0dXJuXG5cbiAgICBjb25zdCBkYXRlRnJvbSA9IHBhcnNlRGF0ZUZyb21UZXh0KG5leHRUZXh0KVxuICAgIGlmICghZGF0ZUZyb20pIHJldHVyblxuXG4gICAgaWYgKGV4aXN0aW5nPy50eXBlICYmIFN0cmluZyhleGlzdGluZy50eXBlKS50b0xvd2VyQ2FzZSgpID09PSBcImVxdWFsc1wiICYmIGV4aXN0aW5nPy5kYXRlRnJvbSkgcmV0dXJuXG5cbiAgICBhcGkuc2V0RmlsdGVyTW9kZWwoe1xuICAgICAgLi4ubW9kZWwsXG4gICAgICBbY29sSWRdOiB7XG4gICAgICAgIC4uLihleGlzdGluZyA/PyB7fSksXG4gICAgICAgIGZpbHRlclR5cGU6IFwiZGF0ZVwiLFxuICAgICAgICB0eXBlOiBcImVxdWFsc1wiLFxuICAgICAgICBkYXRlRnJvbSxcbiAgICAgIH0sXG4gICAgfSlcbiAgICBhcGkub25GaWx0ZXJDaGFuZ2VkPy4oKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UHJlZmVycmVkRmlsdGVyVHlwZShjb2xJZDogc3RyaW5nKSB7XG4gICAgY29uc3QgYXBpID0gZ3JpZEFwaVJlZi5jdXJyZW50XG4gICAgY29uc3QgbW9kZWwgPSAoYXBpPy5nZXRGaWx0ZXJNb2RlbCgpIGFzIFJlY29yZDxzdHJpbmcsIGFueT4pID8/IHt9XG4gICAgY29uc3QgZXhpc3RpbmcgPSBtb2RlbFtjb2xJZF1cbiAgICBjb25zdCBleGlzdGluZ0ZpbHRlclR5cGUgPSB0eXBlb2YgZXhpc3Rpbmc/LmZpbHRlclR5cGUgPT09IFwic3RyaW5nXCIgPyBleGlzdGluZy5maWx0ZXJUeXBlIDogdW5kZWZpbmVkXG4gICAgaWYgKGV4aXN0aW5nRmlsdGVyVHlwZSkgcmV0dXJuIGV4aXN0aW5nRmlsdGVyVHlwZVxuXG4gICAgY29uc3QgY29sRmlsdGVyID0gY29sdW1uRmlsdGVyVHlwZUJ5Q29sSWQuZ2V0KGNvbElkKVxuICAgIGlmIChjb2xGaWx0ZXIgPT09IFwiYWdEYXRlQ29sdW1uRmlsdGVyXCIpIHJldHVybiBcImRhdGVcIlxuICAgIGlmIChjb2xGaWx0ZXIgPT09IFwiYWdOdW1iZXJDb2x1bW5GaWx0ZXJcIikgcmV0dXJuIFwibnVtYmVyXCJcbiAgICByZXR1cm4gXCJ0ZXh0XCJcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUtleURvd25DYXB0dXJlKGV2OiBSZWFjdEtleWJvYXJkRXZlbnQpIHtcbiAgICBjb25zdCBrZXkgPSBldi5rZXk/LnRvTG93ZXJDYXNlKClcbiAgICBjb25zdCBpc0NvcHkgPSAoZXYubWV0YUtleSB8fCBldi5jdHJsS2V5KSAmJiBrZXkgPT09IFwiY1wiICYmICFldi5zaGlmdEtleSAmJiAhZXYuYWx0S2V5XG4gICAgY29uc3QgaXNQYXN0ZSA9IChldi5tZXRhS2V5IHx8IGV2LmN0cmxLZXkpICYmIGtleSA9PT0gXCJ2XCIgJiYgIWV2LnNoaWZ0S2V5ICYmICFldi5hbHRLZXlcblxuICAgIGlmICghaXNDb3B5ICYmICFpc1Bhc3RlKSByZXR1cm5cblxuICAgIGNvbnN0IGNvbElkID0gZmluZEZsb2F0aW5nRmlsdGVyQ29sdW1uSWQoZXYudGFyZ2V0KVxuICAgIGlmICghY29sSWQpIHtcbiAgICAgIGlmIChpc0NvcHkpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGdldEZvY3VzZWRDZWxsVGV4dCgpXG4gICAgICAgIGlmICghdGV4dCkgcmV0dXJuXG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgdm9pZCBjb3B5VGV4dCh0ZXh0KVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGlzUGFzdGUpIHtcbiAgICAgIG9uRmlsdGVyUGFzdGU/Lihjb2xJZClcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZWwgPSBldi50YXJnZXRcbiAgICAgICAgY29uc3QgdmFsdWUgPVxuICAgICAgICAgIGVsIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCB8fCBlbCBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnQgPyBlbC52YWx1ZSA6IHVuZGVmaW5lZFxuICAgICAgICBjb25zdCBmaWx0ZXJUeXBlID0gZ2V0UHJlZmVycmVkRmlsdGVyVHlwZShjb2xJZClcbiAgICAgICAgaWYgKGZpbHRlclR5cGUgPT09IFwiZGF0ZVwiKSB7XG4gICAgICAgICAgc2V0RXF1YWxzRm9yRGF0ZUZpbHRlcihjb2xJZCwgdmFsdWUpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgc2V0RXF1YWxzRm9yVGV4dEZpbHRlcihjb2xJZCwgdmFsdWUpXG4gICAgICB9LCA0MClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChpc0NvcHkpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBnZXRGb2N1c2VkQ2VsbFRleHQoKVxuICAgICAgaWYgKCF0ZXh0KSByZXR1cm5cbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KClcbiAgICAgIHZvaWQgY29weVRleHQodGV4dClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQYXN0ZUNhcHR1cmUoZXY6IFJlYWN0LkNsaXBib2FyZEV2ZW50KSB7XG4gICAgY29uc3QgY29sSWQgPSBmaW5kRmxvYXRpbmdGaWx0ZXJDb2x1bW5JZChldi50YXJnZXQpXG4gICAgaWYgKCFjb2xJZCkgcmV0dXJuXG5cbiAgICBvbkZpbHRlclBhc3RlPy4oY29sSWQpXG4gICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc3QgZWwgPSBldi50YXJnZXRcbiAgICAgIGNvbnN0IHZhbHVlID0gZWwgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50IHx8IGVsIGluc3RhbmNlb2YgSFRNTFRleHRBcmVhRWxlbWVudCA/IGVsLnZhbHVlIDogdW5kZWZpbmVkXG4gICAgICBjb25zdCBmaWx0ZXJUeXBlID0gZ2V0UHJlZmVycmVkRmlsdGVyVHlwZShjb2xJZClcbiAgICAgIGlmIChmaWx0ZXJUeXBlID09PSBcImRhdGVcIikge1xuICAgICAgICBzZXRFcXVhbHNGb3JEYXRlRmlsdGVyKGNvbElkLCB2YWx1ZSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBzZXRFcXVhbHNGb3JUZXh0RmlsdGVyKGNvbElkLCB2YWx1ZSlcbiAgICB9LCA0MClcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZvY3VzZWRDZWxsVGV4dCgpOiBzdHJpbmcgfCBudWxsIHtcbiAgICBjb25zdCBhcGkgPSBncmlkQXBpUmVmLmN1cnJlbnRcbiAgICBpZiAoIWFwaSkgcmV0dXJuIG51bGxcblxuICAgIGNvbnN0IGZvY3VzZWQgPSBhcGkuZ2V0Rm9jdXNlZENlbGw/LigpXG4gICAgaWYgKCFmb2N1c2VkKSByZXR1cm4gbnVsbFxuXG4gICAgY29uc3Qgcm93Tm9kZSA9IGFwaS5nZXREaXNwbGF5ZWRSb3dBdEluZGV4Py4oZm9jdXNlZC5yb3dJbmRleClcbiAgICBjb25zdCBjb2xJZCA9IGZvY3VzZWQuY29sdW1uPy5nZXRDb2xJZD8uKClcbiAgICBpZiAoIXJvd05vZGUgfHwgIWNvbElkKSByZXR1cm4gbnVsbFxuXG4gICAgY29uc3QgdmFsdWUgPSAocm93Tm9kZS5kYXRhIGFzIGFueSk/Lltjb2xJZF1cbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGxcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUgOiBTdHJpbmcodmFsdWUpXG4gIH1cblxuICBjb25zdCBhdXRvQ29sdW1uRGVmcyA9IHVzZU1lbW88Q29sRGVmPFQ+W10+KCgpID0+IHtcbiAgICBpZiAoY29sdW1uRGVmcyAmJiBjb2x1bW5EZWZzLmxlbmd0aCkgcmV0dXJuIGNvbHVtbkRlZnNcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocm93RGF0YT8uWzBdID8/IHt9KVxuICAgIHJldHVybiBrZXlzLm1hcCgoZmllbGQpID0+ICh7IGZpZWxkIH0pKSBhcyBDb2xEZWY8VD5bXVxuICB9LCBbY29sdW1uRGVmcywgcm93RGF0YV0pXG5cbiAgY29uc3QgZGVmYXVsdENvbERlZiA9IHVzZU1lbW88Q29sRGVmPFQ+PihcbiAgICAoKSA9PiAoe1xuICAgICAgcmVzaXphYmxlOiB0cnVlLFxuICAgICAgc29ydGFibGU6IHRydWUsXG4gICAgICB1blNvcnRJY29uOiB0cnVlLFxuICAgICAgZmlsdGVyOiB0cnVlLFxuICAgICAgZmxvYXRpbmdGaWx0ZXI6IHRydWUsXG4gICAgICBtaW5XaWR0aDogMTQwLFxuICAgIH0pLFxuICAgIFtdXG4gIClcblxuICBjb25zdCBtZXJnZWRHcmlkT3B0aW9ucyA9IHVzZU1lbW88R3JpZE9wdGlvbnM8VD4+KFxuICAgICgpID0+ICh7XG4gICAgICB0aGVtZTogXCJsZWdhY3lcIixcbiAgICAgIGFuaW1hdGVSb3dzOiB0cnVlLFxuICAgICAgcm93U2VsZWN0aW9uOiBcInNpbmdsZVwiLFxuICAgICAgc3VwcHJlc3NDZWxsRm9jdXM6IGZhbHNlLFxuICAgICAgcGFnaW5hdGlvbjogZmFsc2UsXG5cbiAgICAgIGFsd2F5c1Nob3dIb3Jpem9udGFsU2Nyb2xsOiB0cnVlLFxuICAgICAgc3VwcHJlc3NIb3Jpem9udGFsU2Nyb2xsOiBmYWxzZSxcbiAgICAgIHN1cHByZXNzUm93Q2xpY2tTZWxlY3Rpb246IHRydWUsXG4gICAgICBlbmFibGVDZWxsVGV4dFNlbGVjdGlvbjogdHJ1ZSxcbiAgICAgIGVuc3VyZURvbU9yZGVyOiB0cnVlLFxuXG4gICAgICAuLi4oZ3JpZE9wdGlvbnMgPz8ge30pLFxuICAgIH0pLFxuICAgIFtncmlkT3B0aW9uc11cbiAgKVxuXG4gIGNvbnN0IGZpbmFsQ2xhc3NOYW1lID0gW1xuICAgIFwiaGJjLWFnLWdyaWQgYWctdGhlbWUtcXVhcnR6LWRhcmsgdy1mdWxsIHJvdW5kZWQtbGcgYm9yZGVyIGJvcmRlci1bY29sb3I6dmFyKC0tY29sb3ItYm9yZGVyKV0gYmctW2NvbG9yOnZhcigtLWNvbG9yLWNhcmQpXVwiLFxuICAgIGNsYXNzTmFtZSxcbiAgXVxuICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAuam9pbihcIiBcIilcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT1cInctZnVsbFwiXG4gICAgICBzdHlsZT17eyBoZWlnaHQgfX1cbiAgICAgIG9uS2V5RG93bkNhcHR1cmU9e2hhbmRsZUtleURvd25DYXB0dXJlfVxuICAgICAgb25QYXN0ZUNhcHR1cmU9e2hhbmRsZVBhc3RlQ2FwdHVyZX1cbiAgICA+XG4gICAgICB7ZXJyb3IgPyAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWItMyByb3VuZGVkLW1kIGJvcmRlciBib3JkZXItcmVkLTUwMC80MCBiZy1yZWQtNTAwLzEwIHB4LTMgcHktMiB0ZXh0LXNtIHRleHQtcmVkLTIwMFwiPlxuICAgICAgICAgIHtlcnJvcn1cbiAgICAgICAgPC9kaXY+XG4gICAgICApIDogbnVsbH1cblxuICAgICAgPGRpdiBjbGFzc05hbWU9e2ZpbmFsQ2xhc3NOYW1lfSBzdHlsZT17eyBoZWlnaHQ6IFwiMTAwJVwiIH19PlxuICAgICAgICA8QWdHcmlkUmVhY3Q8VD5cbiAgICAgICAgICByb3dEYXRhPXtyb3dEYXRhfVxuICAgICAgICAgIGNvbHVtbkRlZnM9e2F1dG9Db2x1bW5EZWZzfVxuICAgICAgICAgIGRlZmF1bHRDb2xEZWY9e2RlZmF1bHRDb2xEZWZ9XG4gICAgICAgICAgZ3JpZE9wdGlvbnM9e21lcmdlZEdyaWRPcHRpb25zfVxuICAgICAgICAgIGxvYWRpbmc9e2xvYWRpbmd9XG4gICAgICAgICAgb25HcmlkUmVhZHk9eyhlKSA9PiB7XG4gICAgICAgICAgICBncmlkQXBpUmVmLmN1cnJlbnQgPSBlLmFwaVxuICAgICAgICAgICAgb25HcmlkUmVhZHk/LihlKVxuICAgICAgICAgIH19XG4gICAgICAgICAgb25GaWx0ZXJDaGFuZ2VkPXtvbkZpbHRlckNoYW5nZWR9XG4gICAgICAgICAgb25Tb3J0Q2hhbmdlZD17b25Tb3J0Q2hhbmdlZH1cbiAgICAgICAgICBvblNlbGVjdGlvbkNoYW5nZWQ9e29uU2VsZWN0aW9uQ2hhbmdlZH1cbiAgICAgICAgICBvbkNlbGxDbGlja2VkPXtvbkNlbGxDbGlja2VkfVxuICAgICAgICAgIG9uQ2VsbERvdWJsZUNsaWNrZWQ9e29uQ2VsbERvdWJsZUNsaWNrZWR9XG4gICAgICAgICAgb25DZWxsS2V5RG93bj17aGFuZGxlQ2VsbEtleURvd259XG4gICAgICAgICAgZ2V0Um93SWQ9e1xuICAgICAgICAgICAgcm93SWRGaWVsZFxuICAgICAgICAgICAgICA/IChwKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCByYXcgPSBwLmRhdGE/Lltyb3dJZEZpZWxkXVxuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByYXcgPT09IFwic3RyaW5nXCIgJiYgcmF3Lmxlbmd0aCkgcmV0dXJuIHJhd1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByYXcgPT09IFwibnVtYmVyXCIpIHJldHVybiBTdHJpbmcocmF3KVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHAuZGF0YSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJBbGxDb21tdW5pdHlNb2R1bGUiLCJNb2R1bGVSZWdpc3RyeSIsIkFnR3JpZFJlYWN0IiwidXNlTWVtbyIsInVzZVJlZiIsImFnR3JpZFJlZ2lzdGVyZWQiLCJyZWdpc3Rlck1vZHVsZXMiLCJIYmNBZ1RhYmxlIiwicm93RGF0YSIsImNvbHVtbkRlZnMiLCJjbGFzc05hbWUiLCJoZWlnaHQiLCJsb2FkaW5nIiwiZXJyb3IiLCJncmlkT3B0aW9ucyIsInJvd0lkRmllbGQiLCJvbkdyaWRSZWFkeSIsIm9uRmlsdGVyQ2hhbmdlZCIsIm9uU29ydENoYW5nZWQiLCJvblNlbGVjdGlvbkNoYW5nZWQiLCJvbkNlbGxDbGlja2VkIiwib25DZWxsRG91YmxlQ2xpY2tlZCIsIm9uQ2VsbEtleURvd24iLCJvbkZpbHRlclBhc3RlIiwiZ3JpZEFwaVJlZiIsImNvbHVtbkZpbHRlclR5cGVCeUNvbElkIiwibWFwIiwiTWFwIiwiZGVmIiwiY29sSWQiLCJmaWVsZCIsInNldCIsImZpbHRlciIsImNvcHlUZXh0IiwidGV4dCIsIm5hdmlnYXRvciIsImNsaXBib2FyZCIsIndyaXRlVGV4dCIsImVsIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwidmFsdWUiLCJzZXRBdHRyaWJ1dGUiLCJzdHlsZSIsInBvc2l0aW9uIiwidG9wIiwiYm9keSIsImFwcGVuZENoaWxkIiwic2VsZWN0IiwiZXhlY0NvbW1hbmQiLCJyZW1vdmVDaGlsZCIsImhhbmRsZUNlbGxLZXlEb3duIiwiZSIsImV2IiwiZXZlbnQiLCJrZXkiLCJ0b0xvd2VyQ2FzZSIsImlzQ29weSIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJ1bmRlZmluZWQiLCJTdHJpbmciLCJwcmV2ZW50RGVmYXVsdCIsImZpbmRGbG9hdGluZ0ZpbHRlckNvbHVtbklkIiwidGFyZ2V0IiwiSFRNTEVsZW1lbnQiLCJkaXJlY3QiLCJjbG9zZXN0IiwiZ2V0QXR0cmlidXRlIiwibGVuZ3RoIiwiZmxvYXRpbmciLCJoZWFkZXJDZWxsIiwic2V0RXF1YWxzRm9yVGV4dEZpbHRlciIsImZpbHRlclRleHQiLCJhcGkiLCJjdXJyZW50IiwibW9kZWwiLCJnZXRGaWx0ZXJNb2RlbCIsImV4aXN0aW5nIiwibmV4dFRleHQiLCJ0cmltbWVkIiwidHJpbSIsInR5cGUiLCJzZXRGaWx0ZXJNb2RlbCIsImZpbHRlclR5cGUiLCJwYXJzZURhdGVGcm9tVGV4dCIsImlucHV0IiwiaXNvTWF0Y2giLCJleGVjIiwibXMiLCJEYXRlIiwicGFyc2UiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsImQiLCJ5eXl5IiwiZ2V0RnVsbFllYXIiLCJwYWRTdGFydCIsIm1tIiwiZ2V0TW9udGgiLCJkZCIsImdldERhdGUiLCJzZXRFcXVhbHNGb3JEYXRlRmlsdGVyIiwiZGF0ZUZyb20iLCJnZXRQcmVmZXJyZWRGaWx0ZXJUeXBlIiwiZXhpc3RpbmdGaWx0ZXJUeXBlIiwiY29sRmlsdGVyIiwiZ2V0IiwiaGFuZGxlS2V5RG93bkNhcHR1cmUiLCJpc1Bhc3RlIiwiZ2V0Rm9jdXNlZENlbGxUZXh0Iiwid2luZG93Iiwic2V0VGltZW91dCIsIkhUTUxJbnB1dEVsZW1lbnQiLCJIVE1MVGV4dEFyZWFFbGVtZW50IiwiaGFuZGxlUGFzdGVDYXB0dXJlIiwiZm9jdXNlZCIsInJvd05vZGUiLCJnZXRGb2N1c2VkQ2VsbCIsImdldERpc3BsYXllZFJvd0F0SW5kZXgiLCJyb3dJbmRleCIsImNvbHVtbiIsImdldENvbElkIiwiZGF0YSIsImF1dG9Db2x1bW5EZWZzIiwia2V5cyIsIk9iamVjdCIsImRlZmF1bHRDb2xEZWYiLCJyZXNpemFibGUiLCJzb3J0YWJsZSIsInVuU29ydEljb24iLCJmbG9hdGluZ0ZpbHRlciIsIm1pbldpZHRoIiwibWVyZ2VkR3JpZE9wdGlvbnMiLCJ0aGVtZSIsImFuaW1hdGVSb3dzIiwicm93U2VsZWN0aW9uIiwic3VwcHJlc3NDZWxsRm9jdXMiLCJwYWdpbmF0aW9uIiwiYWx3YXlzU2hvd0hvcml6b250YWxTY3JvbGwiLCJzdXBwcmVzc0hvcml6b250YWxTY3JvbGwiLCJzdXBwcmVzc1Jvd0NsaWNrU2VsZWN0aW9uIiwiZW5hYmxlQ2VsbFRleHRTZWxlY3Rpb24iLCJlbnN1cmVEb21PcmRlciIsImZpbmFsQ2xhc3NOYW1lIiwiQm9vbGVhbiIsImpvaW4iLCJkaXYiLCJvbktleURvd25DYXB0dXJlIiwib25QYXN0ZUNhcHR1cmUiLCJnZXRSb3dJZCIsInAiLCJyYXciLCJKU09OIiwic3RyaW5naWZ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/hbc/HbcAgTable.tsx\n"));

/***/ })

});